# 项目2-基础架构: 核心组件实现与Disruptor集成

> **学习目标**: 掌握Disruptor框架应用，实现无锁价格引擎核心架构  
> **学习时间**: Day 1-7  
> **代码量**: ~1500行核心代码

## 📋 项目环境搭建

### Maven项目配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                           http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <groupId>com.hft.lockfree</groupId>
    <artifactId>price-engine</artifactId>
    <version>1.0-SNAPSHOT</version>
    
    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        
        <!-- 核心依赖版本 -->
        <disruptor.version>3.4.4</disruptor.version>
        <jmh.version>1.36</jmh.version>
        <hdrhistogram.version>2.1.12</hdrhistogram.version>
        <affinity.version>3.21ea0</affinity.version>
        <slf4j.version>1.7.36</slf4j.version>
    </properties>
    
    <dependencies>
        <!-- LMAX Disruptor: 高性能无锁环形队列 -->
        <dependency>
            <groupId>com.lmax</groupId>
            <artifactId>disruptor</artifactId>
            <version>${disruptor.version}</version>
        </dependency>
        
        <!-- HdrHistogram: 高精度延迟统计 -->
        <dependency>
            <groupId>org.hdrhistogram</groupId>
            <artifactId>HdrHistogram</artifactId>
            <version>${hdrhistogram.version}</version>
        </dependency>
        
        <!-- Java Thread Affinity: CPU亲和性支持 -->
        <dependency>
            <groupId>net.openhft</groupId>
            <artifactId>affinity</artifactId>
            <version>${affinity.version}</version>
        </dependency>
        
        <!-- JMH: 性能基准测试框架 -->
        <dependency>
            <groupId>org.openjdk.jmh</groupId>
            <artifactId>jmh-core</artifactId>
            <version>${jmh.version}</version>
        </dependency>
        <dependency>
            <groupId>org.openjdk.jmh</groupId>
            <artifactId>jmh-generator-annprocess</artifactId>
            <version>${jmh.version}</version>
            <scope>provided</scope>
        </dependency>
        
        <!-- 日志框架 -->
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-simple</artifactId>
            <version>${slf4j.version}</version>
        </dependency>
        
        <!-- 测试框架 -->
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter</artifactId>
            <version>5.9.2</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <source>17</source>
                    <target>17</target>
                    <compilerArgs>
                        <arg>--add-exports</arg>
                        <arg>java.base/sun.misc=ALL-UNNAMED</arg>
                    </compilerArgs>
                </configuration>
            </plugin>
            
            <!-- JMH基准测试插件 -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-shade-plugin</artifactId>
                <version>3.4.1</version>
                <executions>
                    <execution>
                        <phase>package</phase>
                        <goals>
                            <goal>shade</goal>
                        </goals>
                        <configuration>
                            <finalName>benchmarks</finalName>
                            <transformers>
                                <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
                                    <mainClass>org.openjdk.jmh.Main</mainClass>
                                </transformer>
                            </transformers>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>
```

### 项目目录结构

```
src/main/java/com/hft/lockfree/
├── event/                          # 事件模型
│   ├── PriceEvent.java            # 价格事件定义
│   └── PriceEventFactory.java     # 事件工厂
├── handler/                        # 事件处理器
│   ├── ValidationHandler.java     # 数据验证处理器
│   ├── AggregationHandler.java    # 价格聚合处理器
│   └── DistributionHandler.java   # 结果分发处理器
├── engine/                         # 核心引擎
│   ├── LockFreePriceEngine.java   # 主引擎类
│   ├── PriceEngineConfig.java     # 配置管理
│   └── EngineStatistics.java      # 统计信息
├── monitoring/                     # 监控组件
│   ├── LatencyMonitor.java        # 延迟监控
│   └── ThroughputMonitor.java     # 吞吐量监控
└── benchmark/                      # 性能测试
    └── PriceEngineBenchmark.java  # JMH基准测试
```

## 💻 核心组件实现

### 1. 价格事件模型 (PriceEvent.java)

```java
package com.hft.lockfree.event;

import com.lmax.disruptor.EventFactory;

/**
 * 价格事件 - Disruptor的核心事件对象
 * 
 * 设计要点：
 * 1. 可变对象，避免频繁创建
 * 2. 缓存行对齐，避免false sharing
 * 3. 简单字段，减少序列化开销
 */
public class PriceEvent {
    
    // 缓存行填充，避免false sharing (64字节对齐)
    private long p1, p2, p3, p4, p5, p6, p7;
    
    // 核心数据字段
    private String symbol;          // 交易品种
    private double bidPrice;        // 买入价
    private double askPrice;        // 卖出价
    private long timestamp;         // 时间戳(纳秒)
    private int sequence;           // 序列号
    private int sourceId;           // 数据源ID
    
    // 缓存行填充
    private long p8, p9, p10, p11, p12, p13, p14;
    
    /**
     * 重置事件对象，准备复用
     */
    public void reset() {
        this.symbol = null;
        this.bidPrice = 0.0;
        this.askPrice = 0.0;
        this.timestamp = 0L;
        this.sequence = 0;
        this.sourceId = 0;
    }
    
    /**
     * 复制另一个事件的数据
     */
    public void copyFrom(PriceEvent other) {
        this.symbol = other.symbol;
        this.bidPrice = other.bidPrice;
        this.askPrice = other.askPrice;
        this.timestamp = other.timestamp;
        this.sequence = other.sequence;
        this.sourceId = other.sourceId;
    }
    
    /**
     * 设置价格数据
     */
    public void setPrice(String symbol, double bid, double ask, int sourceId) {
        this.symbol = symbol;
        this.bidPrice = bid;
        this.askPrice = ask;
        this.timestamp = System.nanoTime();
        this.sourceId = sourceId;
    }
    
    // Getter和Setter方法
    public String getSymbol() { return symbol; }
    public void setSymbol(String symbol) { this.symbol = symbol; }
    
    public double getBidPrice() { return bidPrice; }
    public void setBidPrice(double bidPrice) { this.bidPrice = bidPrice; }
    
    public double getAskPrice() { return askPrice; }
    public void setAskPrice(double askPrice) { this.askPrice = askPrice; }
    
    public long getTimestamp() { return timestamp; }
    public void setTimestamp(long timestamp) { this.timestamp = timestamp; }
    
    public int getSequence() { return sequence; }
    public void setSequence(int sequence) { this.sequence = sequence; }
    
    public int getSourceId() { return sourceId; }
    public void setSourceId(int sourceId) { this.sourceId = sourceId; }
    
    /**
     * 计算买卖价差
     */
    public double getSpread() {
        return askPrice - bidPrice;
    }
    
    /**
     * 计算中间价
     */
    public double getMidPrice() {
        return (bidPrice + askPrice) / 2.0;
    }
    
    @Override
    public String toString() {
        return String.format("PriceEvent{symbol='%s', bid=%.5f, ask=%.5f, spread=%.5f, ts=%d}", 
                           symbol, bidPrice, askPrice, getSpread(), timestamp);
    }
    
    /**
     * 事件工厂 - Disruptor用于预分配事件对象
     */
    public static final EventFactory<PriceEvent> FACTORY = PriceEvent::new;
}
```

### 2. 引擎配置管理 (PriceEngineConfig.java)

```java
package com.hft.lockfree.engine;

import com.lmax.disruptor.*;

/**
 * 价格引擎配置类
 * 
 * 提供流式API配置引擎参数
 */
public class PriceEngineConfig {
    
    // 默认配置值
    private static final int DEFAULT_RING_BUFFER_SIZE = 64 * 1024; // 64K，必须是2的幂
    private static final WaitStrategy DEFAULT_WAIT_STRATEGY = new YieldingWaitStrategy();
    private static final boolean DEFAULT_SINGLE_PRODUCER = true;
    
    // 配置参数
    private int ringBufferSize = DEFAULT_RING_BUFFER_SIZE;
    private WaitStrategy waitStrategy = DEFAULT_WAIT_STRATEGY;
    private boolean singleProducer = DEFAULT_SINGLE_PRODUCER;
    private boolean enableCpuAffinity = false;
    private int[] cpuAffinityMask = new int[0];
    private boolean enableLatencyMonitoring = true;
    private boolean enableThroughputMonitoring = true;
    
    private PriceEngineConfig() {}
    
    /**
     * 创建配置构建器
     */
    public static PriceEngineConfig builder() {
        return new PriceEngineConfig();
    }
    
    /**
     * 设置RingBuffer大小 (必须是2的幂)
     */
    public PriceEngineConfig ringBufferSize(int size) {
        if (Integer.bitCount(size) != 1) {
            throw new IllegalArgumentException("Ring buffer size must be a power of 2");
        }
        this.ringBufferSize = size;
        return this;
    }
    
    /**
     * 设置等待策略
     */
    public PriceEngineConfig waitStrategy(WaitStrategy strategy) {
        this.waitStrategy = strategy;
        return this;
    }
    
    /**
     * 使用忙等待策略 (最低延迟，高CPU使用)
     */
    public PriceEngineConfig busySpinWaitStrategy() {
        this.waitStrategy = new BusySpinWaitStrategy();
        return this;
    }
    
    /**
     * 使用让步等待策略 (平衡延迟和CPU使用)
     */
    public PriceEngineConfig yieldingWaitStrategy() {
        this.waitStrategy = new YieldingWaitStrategy();
        return this;
    }
    
    /**
     * 使用睡眠等待策略 (低CPU使用，较高延迟)
     */
    public PriceEngineConfig sleepingWaitStrategy() {
        this.waitStrategy = new SleepingWaitStrategy();
        return this;
    }
    
    /**
     * 使用阻塞等待策略 (最低CPU使用，最高延迟)
     */
    public PriceEngineConfig blockingWaitStrategy() {
        this.waitStrategy = new BlockingWaitStrategy();
        return this;
    }
    
    /**
     * 启用单生产者模式 (更高性能)
     */
    public PriceEngineConfig singleProducer() {
        this.singleProducer = true;
        return this;
    }
    
    /**
     * 启用多生产者模式
     */
    public PriceEngineConfig multiProducer() {
        this.singleProducer = false;
        return this;
    }
    
    /**
     * 启用CPU亲和性
     */
    public PriceEngineConfig enableCpuAffinity(int... cpuMask) {
        this.enableCpuAffinity = true;
        this.cpuAffinityMask = cpuMask.clone();
        return this;
    }
    
    /**
     * 禁用延迟监控 (提升性能)
     */
    public PriceEngineConfig disableLatencyMonitoring() {
        this.enableLatencyMonitoring = false;
        return this;
    }
    
    /**
     * 禁用吞吐量监控
     */
    public PriceEngineConfig disableThroughputMonitoring() {
        this.enableThroughputMonitoring = false;
        return this;
    }
    
    // Getter方法
    public int getRingBufferSize() { return ringBufferSize; }
    public WaitStrategy getWaitStrategy() { return waitStrategy; }
    public boolean isSingleProducer() { return singleProducer; }
    public boolean isCpuAffinityEnabled() { return enableCpuAffinity; }
    public int[] getCpuAffinityMask() { return cpuAffinityMask.clone(); }
    public boolean isLatencyMonitoringEnabled() { return enableLatencyMonitoring; }
    public boolean isThroughputMonitoringEnabled() { return enableThroughputMonitoring; }
    
    /**
     * 验证配置有效性
     */
    public void validate() {
        if (ringBufferSize <= 0) {
            throw new IllegalArgumentException("Ring buffer size must be positive");
        }
        if (waitStrategy == null) {
            throw new IllegalArgumentException("Wait strategy cannot be null");
        }
        if (enableCpuAffinity && cpuAffinityMask.length == 0) {
            throw new IllegalArgumentException("CPU affinity mask cannot be empty when enabled");
        }
    }
    
    @Override
    public String toString() {
        return String.format("PriceEngineConfig{ringBufferSize=%d, waitStrategy=%s, singleProducer=%s, cpuAffinity=%s}",
                           ringBufferSize, waitStrategy.getClass().getSimpleName(), singleProducer, enableCpuAffinity);
    }
}
```

### 3. 事件处理器基类

```java
package com.hft.lockfree.handler;

import com.hft.lockfree.event.PriceEvent;
import com.lmax.disruptor.EventHandler;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * 抽象事件处理器基类
 * 
 * 提供通用的处理器功能：
 * 1. 错误处理
 * 2. 性能统计
 * 3. 日志记录
 */
public abstract class AbstractPriceEventHandler implements EventHandler<PriceEvent> {
    
    protected final Logger logger = LoggerFactory.getLogger(getClass());
    
    // 性能统计
    private volatile long processedCount = 0;
    private volatile long errorCount = 0;
    private volatile long totalProcessingTime = 0;
    
    @Override
    public final void onEvent(PriceEvent event, long sequence, boolean endOfBatch) throws Exception {
        long startTime = System.nanoTime();
        
        try {
            // 调用具体的处理逻辑
            processEvent(event, sequence, endOfBatch);
            
            // 更新统计信息
            processedCount++;
            totalProcessingTime += (System.nanoTime() - startTime);
            
        } catch (Exception e) {
            errorCount++;
            logger.error("Error processing event: {}", event, e);
            
            // 调用错误处理
            handleError(event, sequence, e);
        }
    }
    
    /**
     * 具体的事件处理逻辑，由子类实现
     */
    protected abstract void processEvent(PriceEvent event, long sequence, boolean endOfBatch) throws Exception;
    
    /**
     * 错误处理，子类可以重写
     */
    protected void handleError(PriceEvent event, long sequence, Exception error) {
        // 默认实现：记录错误日志
        logger.warn("Failed to process event at sequence {}: {}", sequence, error.getMessage());
    }
    
    /**
     * 获取处理器名称
     */
    public abstract String getHandlerName();
    
    /**
     * 获取性能统计信息
     */
    public HandlerStatistics getStatistics() {
        return new HandlerStatistics(
            getHandlerName(),
            processedCount,
            errorCount,
            processedCount > 0 ? totalProcessingTime / processedCount : 0
        );
    }
    
    /**
     * 重置统计信息
     */
    public void resetStatistics() {
        processedCount = 0;
        errorCount = 0;
        totalProcessingTime = 0;
    }
    
    /**
     * 处理器统计信息
     */
    public static class HandlerStatistics {
        private final String handlerName;
        private final long processedCount;
        private final long errorCount;
        private final long averageProcessingTime;
        
        public HandlerStatistics(String handlerName, long processedCount, long errorCount, long averageProcessingTime) {
            this.handlerName = handlerName;
            this.processedCount = processedCount;
            this.errorCount = errorCount;
            this.averageProcessingTime = averageProcessingTime;
        }
        
        // Getter方法
        public String getHandlerName() { return handlerName; }
        public long getProcessedCount() { return processedCount; }
        public long getErrorCount() { return errorCount; }
        public long getAverageProcessingTime() { return averageProcessingTime; }
        public double getErrorRate() { 
            return processedCount > 0 ? (double) errorCount / processedCount : 0.0; 
        }
        
        @Override
        public String toString() {
            return String.format("%s: processed=%d, errors=%d (%.2f%%), avgTime=%dns",
                               handlerName, processedCount, errorCount, getErrorRate() * 100, averageProcessingTime);
        }
    }
}
```

## 🔧 核心引擎框架

### LockFreePriceEngine 主引擎类结构

```java
package com.hft.lockfree.engine;

import com.hft.lockfree.event.PriceEvent;
import com.hft.lockfree.handler.*;
import com.lmax.disruptor.*;
import com.lmax.disruptor.dsl.Disruptor;
import com.lmax.disruptor.dsl.ProducerType;

/**
 * 无锁价格引擎主类
 * 
 * 核心功能：
 * 1. Disruptor生命周期管理
 * 2. 事件发布接口
 * 3. 处理器链配置
 * 4. 性能监控集成
 */
public class LockFreePriceEngine {
    
    // 核心组件
    private final PriceEngineConfig config;
    private final Disruptor<PriceEvent> disruptor;
    private final RingBuffer<PriceEvent> ringBuffer;
    
    // 事件处理器
    private final ValidationHandler validationHandler;
    private final AggregationHandler aggregationHandler;
    private final DistributionHandler distributionHandler;
    
    // 监控组件
    private final LatencyMonitor latencyMonitor;
    private final ThroughputMonitor throughputMonitor;
    
    // 状态管理
    private volatile boolean started = false;
    private volatile boolean shutdown = false;
    
    /**
     * 构造函数
     */
    public LockFreePriceEngine(PriceEngineConfig config) {
        this.config = config;
        config.validate();
        
        // 创建事件处理器
        this.validationHandler = new ValidationHandler();
        this.aggregationHandler = new AggregationHandler();
        this.distributionHandler = new DistributionHandler();
        
        // 创建监控组件
        this.latencyMonitor = config.isLatencyMonitoringEnabled() ? new LatencyMonitor() : null;
        this.throughputMonitor = config.isThroughputMonitoringEnabled() ? new ThroughputMonitor() : null;
        
        // 创建Disruptor
        this.disruptor = createDisruptor();
        this.ringBuffer = disruptor.getRingBuffer();
        
        // 配置处理器链
        configureEventHandlers();
    }
    
    /**
     * 创建Disruptor实例
     */
    private Disruptor<PriceEvent> createDisruptor() {
        ThreadFactory threadFactory = new PriceEngineThreadFactory();
        ProducerType producerType = config.isSingleProducer() ? 
            ProducerType.SINGLE : ProducerType.MULTI;
        
        return new Disruptor<>(
            PriceEvent.FACTORY,
            config.getRingBufferSize(),
            threadFactory,
            producerType,
            config.getWaitStrategy()
        );
    }
    
    /**
     * 配置事件处理器链
     */
    private void configureEventHandlers() {
        // 配置处理器依赖关系：validation -> aggregation -> distribution
        disruptor.handleEventsWith(validationHandler)
                 .then(aggregationHandler)
                 .then(distributionHandler);
        
        // 配置异常处理器
        disruptor.setDefaultExceptionHandler(new PriceEngineExceptionHandler());
    }
    
    // 其他方法框架...
    public void start() { /* 启动引擎 */ }
    public void shutdown() { /* 关闭引擎 */ }
    public boolean publishPrice(String symbol, double bid, double ask) { /* 发布价格 */ }
    public EngineStatistics getStatistics() { /* 获取统计信息 */ }
}
```

## 📚 学习要点总结

### 关键技术概念

1. **Disruptor RingBuffer**: 预分配的环形队列，避免GC
2. **事件驱动架构**: 通过事件传递实现解耦
3. **处理器链模式**: 流水线式的事件处理
4. **缓存行对齐**: 避免false sharing提升性能

### 下一步学习

- [项目2-性能优化.md](./项目2-性能优化.md) - 深入无锁编程和CPU优化
- [项目2-测试验证.md](./项目2-测试验证.md) - JMH基准测试实践

### 面试要点

- 能够解释Disruptor的工作原理和优势
- 理解无锁编程的基本概念和应用场景
- 掌握Java并发编程的最佳实践
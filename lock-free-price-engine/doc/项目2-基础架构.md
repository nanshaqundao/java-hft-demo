# é¡¹ç›®2-åŸºç¡€æ¶æ„: æ ¸å¿ƒç»„ä»¶å®ç°ä¸Disruptoré›†æˆ

> **å­¦ä¹ ç›®æ ‡**: æŒæ¡Disruptoræ¡†æ¶åº”ç”¨ï¼Œå®ç°æ— é”ä»·æ ¼å¼•æ“æ ¸å¿ƒæ¶æ„  
> **å­¦ä¹ æ—¶é—´**: Day 1-7  
> **ä»£ç é‡**: ~1500è¡Œæ ¸å¿ƒä»£ç 

## ğŸ“‹ é¡¹ç›®ç¯å¢ƒæ­å»º

### Mavené¡¹ç›®é…ç½®

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                           http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <groupId>com.hft.lockfree</groupId>
    <artifactId>price-engine</artifactId>
    <version>1.0-SNAPSHOT</version>
    
    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        
        <!-- æ ¸å¿ƒä¾èµ–ç‰ˆæœ¬ -->
        <disruptor.version>3.4.4</disruptor.version>
        <jmh.version>1.36</jmh.version>
        <hdrhistogram.version>2.1.12</hdrhistogram.version>
        <affinity.version>3.21ea0</affinity.version>
        <slf4j.version>1.7.36</slf4j.version>
    </properties>
    
    <dependencies>
        <!-- LMAX Disruptor: é«˜æ€§èƒ½æ— é”ç¯å½¢é˜Ÿåˆ— -->
        <dependency>
            <groupId>com.lmax</groupId>
            <artifactId>disruptor</artifactId>
            <version>${disruptor.version}</version>
        </dependency>
        
        <!-- HdrHistogram: é«˜ç²¾åº¦å»¶è¿Ÿç»Ÿè®¡ -->
        <dependency>
            <groupId>org.hdrhistogram</groupId>
            <artifactId>HdrHistogram</artifactId>
            <version>${hdrhistogram.version}</version>
        </dependency>
        
        <!-- Java Thread Affinity: CPUäº²å’Œæ€§æ”¯æŒ -->
        <dependency>
            <groupId>net.openhft</groupId>
            <artifactId>affinity</artifactId>
            <version>${affinity.version}</version>
        </dependency>
        
        <!-- JMH: æ€§èƒ½åŸºå‡†æµ‹è¯•æ¡†æ¶ -->
        <dependency>
            <groupId>org.openjdk.jmh</groupId>
            <artifactId>jmh-core</artifactId>
            <version>${jmh.version}</version>
        </dependency>
        <dependency>
            <groupId>org.openjdk.jmh</groupId>
            <artifactId>jmh-generator-annprocess</artifactId>
            <version>${jmh.version}</version>
            <scope>provided</scope>
        </dependency>
        
        <!-- æ—¥å¿—æ¡†æ¶ -->
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-simple</artifactId>
            <version>${slf4j.version}</version>
        </dependency>
        
        <!-- æµ‹è¯•æ¡†æ¶ -->
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter</artifactId>
            <version>5.9.2</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <source>17</source>
                    <target>17</target>
                    <compilerArgs>
                        <arg>--add-exports</arg>
                        <arg>java.base/sun.misc=ALL-UNNAMED</arg>
                    </compilerArgs>
                </configuration>
            </plugin>
            
            <!-- JMHåŸºå‡†æµ‹è¯•æ’ä»¶ -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-shade-plugin</artifactId>
                <version>3.4.1</version>
                <executions>
                    <execution>
                        <phase>package</phase>
                        <goals>
                            <goal>shade</goal>
                        </goals>
                        <configuration>
                            <finalName>benchmarks</finalName>
                            <transformers>
                                <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
                                    <mainClass>org.openjdk.jmh.Main</mainClass>
                                </transformer>
                            </transformers>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>
```

### é¡¹ç›®ç›®å½•ç»“æ„

```
src/main/java/com/hft/lockfree/
â”œâ”€â”€ event/                          # äº‹ä»¶æ¨¡å‹
â”‚   â”œâ”€â”€ PriceEvent.java            # ä»·æ ¼äº‹ä»¶å®šä¹‰
â”‚   â””â”€â”€ PriceEventFactory.java     # äº‹ä»¶å·¥å‚
â”œâ”€â”€ handler/                        # äº‹ä»¶å¤„ç†å™¨
â”‚   â”œâ”€â”€ ValidationHandler.java     # æ•°æ®éªŒè¯å¤„ç†å™¨
â”‚   â”œâ”€â”€ AggregationHandler.java    # ä»·æ ¼èšåˆå¤„ç†å™¨
â”‚   â””â”€â”€ DistributionHandler.java   # ç»“æœåˆ†å‘å¤„ç†å™¨
â”œâ”€â”€ engine/                         # æ ¸å¿ƒå¼•æ“
â”‚   â”œâ”€â”€ LockFreePriceEngine.java   # ä¸»å¼•æ“ç±»
â”‚   â”œâ”€â”€ PriceEngineConfig.java     # é…ç½®ç®¡ç†
â”‚   â””â”€â”€ EngineStatistics.java      # ç»Ÿè®¡ä¿¡æ¯
â”œâ”€â”€ monitoring/                     # ç›‘æ§ç»„ä»¶
â”‚   â”œâ”€â”€ LatencyMonitor.java        # å»¶è¿Ÿç›‘æ§
â”‚   â””â”€â”€ ThroughputMonitor.java     # ååé‡ç›‘æ§
â””â”€â”€ benchmark/                      # æ€§èƒ½æµ‹è¯•
    â””â”€â”€ PriceEngineBenchmark.java  # JMHåŸºå‡†æµ‹è¯•
```

## ğŸ’» æ ¸å¿ƒç»„ä»¶å®ç°

### 1. ä»·æ ¼äº‹ä»¶æ¨¡å‹ (PriceEvent.java)

```java
package com.hft.lockfree.event;

import com.lmax.disruptor.EventFactory;

/**
 * ä»·æ ¼äº‹ä»¶ - Disruptorçš„æ ¸å¿ƒäº‹ä»¶å¯¹è±¡
 * 
 * è®¾è®¡è¦ç‚¹ï¼š
 * 1. å¯å˜å¯¹è±¡ï¼Œé¿å…é¢‘ç¹åˆ›å»º
 * 2. ç¼“å­˜è¡Œå¯¹é½ï¼Œé¿å…false sharing
 * 3. ç®€å•å­—æ®µï¼Œå‡å°‘åºåˆ—åŒ–å¼€é”€
 */
public class PriceEvent {
    
    // ç¼“å­˜è¡Œå¡«å……ï¼Œé¿å…false sharing (64å­—èŠ‚å¯¹é½)
    private long p1, p2, p3, p4, p5, p6, p7;
    
    // æ ¸å¿ƒæ•°æ®å­—æ®µ
    private String symbol;          // äº¤æ˜“å“ç§
    private double bidPrice;        // ä¹°å…¥ä»·
    private double askPrice;        // å–å‡ºä»·
    private long timestamp;         // æ—¶é—´æˆ³(çº³ç§’)
    private int sequence;           // åºåˆ—å·
    private int sourceId;           // æ•°æ®æºID
    
    // ç¼“å­˜è¡Œå¡«å……
    private long p8, p9, p10, p11, p12, p13, p14;
    
    /**
     * é‡ç½®äº‹ä»¶å¯¹è±¡ï¼Œå‡†å¤‡å¤ç”¨
     */
    public void reset() {
        this.symbol = null;
        this.bidPrice = 0.0;
        this.askPrice = 0.0;
        this.timestamp = 0L;
        this.sequence = 0;
        this.sourceId = 0;
    }
    
    /**
     * å¤åˆ¶å¦ä¸€ä¸ªäº‹ä»¶çš„æ•°æ®
     */
    public void copyFrom(PriceEvent other) {
        this.symbol = other.symbol;
        this.bidPrice = other.bidPrice;
        this.askPrice = other.askPrice;
        this.timestamp = other.timestamp;
        this.sequence = other.sequence;
        this.sourceId = other.sourceId;
    }
    
    /**
     * è®¾ç½®ä»·æ ¼æ•°æ®
     */
    public void setPrice(String symbol, double bid, double ask, int sourceId) {
        this.symbol = symbol;
        this.bidPrice = bid;
        this.askPrice = ask;
        this.timestamp = System.nanoTime();
        this.sourceId = sourceId;
    }
    
    // Getterå’ŒSetteræ–¹æ³•
    public String getSymbol() { return symbol; }
    public void setSymbol(String symbol) { this.symbol = symbol; }
    
    public double getBidPrice() { return bidPrice; }
    public void setBidPrice(double bidPrice) { this.bidPrice = bidPrice; }
    
    public double getAskPrice() { return askPrice; }
    public void setAskPrice(double askPrice) { this.askPrice = askPrice; }
    
    public long getTimestamp() { return timestamp; }
    public void setTimestamp(long timestamp) { this.timestamp = timestamp; }
    
    public int getSequence() { return sequence; }
    public void setSequence(int sequence) { this.sequence = sequence; }
    
    public int getSourceId() { return sourceId; }
    public void setSourceId(int sourceId) { this.sourceId = sourceId; }
    
    /**
     * è®¡ç®—ä¹°å–ä»·å·®
     */
    public double getSpread() {
        return askPrice - bidPrice;
    }
    
    /**
     * è®¡ç®—ä¸­é—´ä»·
     */
    public double getMidPrice() {
        return (bidPrice + askPrice) / 2.0;
    }
    
    @Override
    public String toString() {
        return String.format("PriceEvent{symbol='%s', bid=%.5f, ask=%.5f, spread=%.5f, ts=%d}", 
                           symbol, bidPrice, askPrice, getSpread(), timestamp);
    }
    
    /**
     * äº‹ä»¶å·¥å‚ - Disruptorç”¨äºé¢„åˆ†é…äº‹ä»¶å¯¹è±¡
     */
    public static final EventFactory<PriceEvent> FACTORY = PriceEvent::new;
}
```

### 2. å¼•æ“é…ç½®ç®¡ç† (PriceEngineConfig.java)

```java
package com.hft.lockfree.engine;

import com.lmax.disruptor.*;

/**
 * ä»·æ ¼å¼•æ“é…ç½®ç±»
 * 
 * æä¾›æµå¼APIé…ç½®å¼•æ“å‚æ•°
 */
public class PriceEngineConfig {
    
    // é»˜è®¤é…ç½®å€¼
    private static final int DEFAULT_RING_BUFFER_SIZE = 64 * 1024; // 64Kï¼Œå¿…é¡»æ˜¯2çš„å¹‚
    private static final WaitStrategy DEFAULT_WAIT_STRATEGY = new YieldingWaitStrategy();
    private static final boolean DEFAULT_SINGLE_PRODUCER = true;
    
    // é…ç½®å‚æ•°
    private int ringBufferSize = DEFAULT_RING_BUFFER_SIZE;
    private WaitStrategy waitStrategy = DEFAULT_WAIT_STRATEGY;
    private boolean singleProducer = DEFAULT_SINGLE_PRODUCER;
    private boolean enableCpuAffinity = false;
    private int[] cpuAffinityMask = new int[0];
    private boolean enableLatencyMonitoring = true;
    private boolean enableThroughputMonitoring = true;
    
    private PriceEngineConfig() {}
    
    /**
     * åˆ›å»ºé…ç½®æ„å»ºå™¨
     */
    public static PriceEngineConfig builder() {
        return new PriceEngineConfig();
    }
    
    /**
     * è®¾ç½®RingBufferå¤§å° (å¿…é¡»æ˜¯2çš„å¹‚)
     */
    public PriceEngineConfig ringBufferSize(int size) {
        if (Integer.bitCount(size) != 1) {
            throw new IllegalArgumentException("Ring buffer size must be a power of 2");
        }
        this.ringBufferSize = size;
        return this;
    }
    
    /**
     * è®¾ç½®ç­‰å¾…ç­–ç•¥
     */
    public PriceEngineConfig waitStrategy(WaitStrategy strategy) {
        this.waitStrategy = strategy;
        return this;
    }
    
    /**
     * ä½¿ç”¨å¿™ç­‰å¾…ç­–ç•¥ (æœ€ä½å»¶è¿Ÿï¼Œé«˜CPUä½¿ç”¨)
     */
    public PriceEngineConfig busySpinWaitStrategy() {
        this.waitStrategy = new BusySpinWaitStrategy();
        return this;
    }
    
    /**
     * ä½¿ç”¨è®©æ­¥ç­‰å¾…ç­–ç•¥ (å¹³è¡¡å»¶è¿Ÿå’ŒCPUä½¿ç”¨)
     */
    public PriceEngineConfig yieldingWaitStrategy() {
        this.waitStrategy = new YieldingWaitStrategy();
        return this;
    }
    
    /**
     * ä½¿ç”¨ç¡çœ ç­‰å¾…ç­–ç•¥ (ä½CPUä½¿ç”¨ï¼Œè¾ƒé«˜å»¶è¿Ÿ)
     */
    public PriceEngineConfig sleepingWaitStrategy() {
        this.waitStrategy = new SleepingWaitStrategy();
        return this;
    }
    
    /**
     * ä½¿ç”¨é˜»å¡ç­‰å¾…ç­–ç•¥ (æœ€ä½CPUä½¿ç”¨ï¼Œæœ€é«˜å»¶è¿Ÿ)
     */
    public PriceEngineConfig blockingWaitStrategy() {
        this.waitStrategy = new BlockingWaitStrategy();
        return this;
    }
    
    /**
     * å¯ç”¨å•ç”Ÿäº§è€…æ¨¡å¼ (æ›´é«˜æ€§èƒ½)
     */
    public PriceEngineConfig singleProducer() {
        this.singleProducer = true;
        return this;
    }
    
    /**
     * å¯ç”¨å¤šç”Ÿäº§è€…æ¨¡å¼
     */
    public PriceEngineConfig multiProducer() {
        this.singleProducer = false;
        return this;
    }
    
    /**
     * å¯ç”¨CPUäº²å’Œæ€§
     */
    public PriceEngineConfig enableCpuAffinity(int... cpuMask) {
        this.enableCpuAffinity = true;
        this.cpuAffinityMask = cpuMask.clone();
        return this;
    }
    
    /**
     * ç¦ç”¨å»¶è¿Ÿç›‘æ§ (æå‡æ€§èƒ½)
     */
    public PriceEngineConfig disableLatencyMonitoring() {
        this.enableLatencyMonitoring = false;
        return this;
    }
    
    /**
     * ç¦ç”¨ååé‡ç›‘æ§
     */
    public PriceEngineConfig disableThroughputMonitoring() {
        this.enableThroughputMonitoring = false;
        return this;
    }
    
    // Getteræ–¹æ³•
    public int getRingBufferSize() { return ringBufferSize; }
    public WaitStrategy getWaitStrategy() { return waitStrategy; }
    public boolean isSingleProducer() { return singleProducer; }
    public boolean isCpuAffinityEnabled() { return enableCpuAffinity; }
    public int[] getCpuAffinityMask() { return cpuAffinityMask.clone(); }
    public boolean isLatencyMonitoringEnabled() { return enableLatencyMonitoring; }
    public boolean isThroughputMonitoringEnabled() { return enableThroughputMonitoring; }
    
    /**
     * éªŒè¯é…ç½®æœ‰æ•ˆæ€§
     */
    public void validate() {
        if (ringBufferSize <= 0) {
            throw new IllegalArgumentException("Ring buffer size must be positive");
        }
        if (waitStrategy == null) {
            throw new IllegalArgumentException("Wait strategy cannot be null");
        }
        if (enableCpuAffinity && cpuAffinityMask.length == 0) {
            throw new IllegalArgumentException("CPU affinity mask cannot be empty when enabled");
        }
    }
    
    @Override
    public String toString() {
        return String.format("PriceEngineConfig{ringBufferSize=%d, waitStrategy=%s, singleProducer=%s, cpuAffinity=%s}",
                           ringBufferSize, waitStrategy.getClass().getSimpleName(), singleProducer, enableCpuAffinity);
    }
}
```

### 3. äº‹ä»¶å¤„ç†å™¨åŸºç±»

```java
package com.hft.lockfree.handler;

import com.hft.lockfree.event.PriceEvent;
import com.lmax.disruptor.EventHandler;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * æŠ½è±¡äº‹ä»¶å¤„ç†å™¨åŸºç±»
 * 
 * æä¾›é€šç”¨çš„å¤„ç†å™¨åŠŸèƒ½ï¼š
 * 1. é”™è¯¯å¤„ç†
 * 2. æ€§èƒ½ç»Ÿè®¡
 * 3. æ—¥å¿—è®°å½•
 */
public abstract class AbstractPriceEventHandler implements EventHandler<PriceEvent> {
    
    protected final Logger logger = LoggerFactory.getLogger(getClass());
    
    // æ€§èƒ½ç»Ÿè®¡
    private volatile long processedCount = 0;
    private volatile long errorCount = 0;
    private volatile long totalProcessingTime = 0;
    
    @Override
    public final void onEvent(PriceEvent event, long sequence, boolean endOfBatch) throws Exception {
        long startTime = System.nanoTime();
        
        try {
            // è°ƒç”¨å…·ä½“çš„å¤„ç†é€»è¾‘
            processEvent(event, sequence, endOfBatch);
            
            // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
            processedCount++;
            totalProcessingTime += (System.nanoTime() - startTime);
            
        } catch (Exception e) {
            errorCount++;
            logger.error("Error processing event: {}", event, e);
            
            // è°ƒç”¨é”™è¯¯å¤„ç†
            handleError(event, sequence, e);
        }
    }
    
    /**
     * å…·ä½“çš„äº‹ä»¶å¤„ç†é€»è¾‘ï¼Œç”±å­ç±»å®ç°
     */
    protected abstract void processEvent(PriceEvent event, long sequence, boolean endOfBatch) throws Exception;
    
    /**
     * é”™è¯¯å¤„ç†ï¼Œå­ç±»å¯ä»¥é‡å†™
     */
    protected void handleError(PriceEvent event, long sequence, Exception error) {
        // é»˜è®¤å®ç°ï¼šè®°å½•é”™è¯¯æ—¥å¿—
        logger.warn("Failed to process event at sequence {}: {}", sequence, error.getMessage());
    }
    
    /**
     * è·å–å¤„ç†å™¨åç§°
     */
    public abstract String getHandlerName();
    
    /**
     * è·å–æ€§èƒ½ç»Ÿè®¡ä¿¡æ¯
     */
    public HandlerStatistics getStatistics() {
        return new HandlerStatistics(
            getHandlerName(),
            processedCount,
            errorCount,
            processedCount > 0 ? totalProcessingTime / processedCount : 0
        );
    }
    
    /**
     * é‡ç½®ç»Ÿè®¡ä¿¡æ¯
     */
    public void resetStatistics() {
        processedCount = 0;
        errorCount = 0;
        totalProcessingTime = 0;
    }
    
    /**
     * å¤„ç†å™¨ç»Ÿè®¡ä¿¡æ¯
     */
    public static class HandlerStatistics {
        private final String handlerName;
        private final long processedCount;
        private final long errorCount;
        private final long averageProcessingTime;
        
        public HandlerStatistics(String handlerName, long processedCount, long errorCount, long averageProcessingTime) {
            this.handlerName = handlerName;
            this.processedCount = processedCount;
            this.errorCount = errorCount;
            this.averageProcessingTime = averageProcessingTime;
        }
        
        // Getteræ–¹æ³•
        public String getHandlerName() { return handlerName; }
        public long getProcessedCount() { return processedCount; }
        public long getErrorCount() { return errorCount; }
        public long getAverageProcessingTime() { return averageProcessingTime; }
        public double getErrorRate() { 
            return processedCount > 0 ? (double) errorCount / processedCount : 0.0; 
        }
        
        @Override
        public String toString() {
            return String.format("%s: processed=%d, errors=%d (%.2f%%), avgTime=%dns",
                               handlerName, processedCount, errorCount, getErrorRate() * 100, averageProcessingTime);
        }
    }
}
```

## ğŸ”§ æ ¸å¿ƒå¼•æ“æ¡†æ¶

### LockFreePriceEngine ä¸»å¼•æ“ç±»ç»“æ„

```java
package com.hft.lockfree.engine;

import com.hft.lockfree.event.PriceEvent;
import com.hft.lockfree.handler.*;
import com.lmax.disruptor.*;
import com.lmax.disruptor.dsl.Disruptor;
import com.lmax.disruptor.dsl.ProducerType;

/**
 * æ— é”ä»·æ ¼å¼•æ“ä¸»ç±»
 * 
 * æ ¸å¿ƒåŠŸèƒ½ï¼š
 * 1. Disruptorç”Ÿå‘½å‘¨æœŸç®¡ç†
 * 2. äº‹ä»¶å‘å¸ƒæ¥å£
 * 3. å¤„ç†å™¨é“¾é…ç½®
 * 4. æ€§èƒ½ç›‘æ§é›†æˆ
 */
public class LockFreePriceEngine {
    
    // æ ¸å¿ƒç»„ä»¶
    private final PriceEngineConfig config;
    private final Disruptor<PriceEvent> disruptor;
    private final RingBuffer<PriceEvent> ringBuffer;
    
    // äº‹ä»¶å¤„ç†å™¨
    private final ValidationHandler validationHandler;
    private final AggregationHandler aggregationHandler;
    private final DistributionHandler distributionHandler;
    
    // ç›‘æ§ç»„ä»¶
    private final LatencyMonitor latencyMonitor;
    private final ThroughputMonitor throughputMonitor;
    
    // çŠ¶æ€ç®¡ç†
    private volatile boolean started = false;
    private volatile boolean shutdown = false;
    
    /**
     * æ„é€ å‡½æ•°
     */
    public LockFreePriceEngine(PriceEngineConfig config) {
        this.config = config;
        config.validate();
        
        // åˆ›å»ºäº‹ä»¶å¤„ç†å™¨
        this.validationHandler = new ValidationHandler();
        this.aggregationHandler = new AggregationHandler();
        this.distributionHandler = new DistributionHandler();
        
        // åˆ›å»ºç›‘æ§ç»„ä»¶
        this.latencyMonitor = config.isLatencyMonitoringEnabled() ? new LatencyMonitor() : null;
        this.throughputMonitor = config.isThroughputMonitoringEnabled() ? new ThroughputMonitor() : null;
        
        // åˆ›å»ºDisruptor
        this.disruptor = createDisruptor();
        this.ringBuffer = disruptor.getRingBuffer();
        
        // é…ç½®å¤„ç†å™¨é“¾
        configureEventHandlers();
    }
    
    /**
     * åˆ›å»ºDisruptorå®ä¾‹
     */
    private Disruptor<PriceEvent> createDisruptor() {
        ThreadFactory threadFactory = new PriceEngineThreadFactory();
        ProducerType producerType = config.isSingleProducer() ? 
            ProducerType.SINGLE : ProducerType.MULTI;
        
        return new Disruptor<>(
            PriceEvent.FACTORY,
            config.getRingBufferSize(),
            threadFactory,
            producerType,
            config.getWaitStrategy()
        );
    }
    
    /**
     * é…ç½®äº‹ä»¶å¤„ç†å™¨é“¾
     */
    private void configureEventHandlers() {
        // é…ç½®å¤„ç†å™¨ä¾èµ–å…³ç³»ï¼švalidation -> aggregation -> distribution
        disruptor.handleEventsWith(validationHandler)
                 .then(aggregationHandler)
                 .then(distributionHandler);
        
        // é…ç½®å¼‚å¸¸å¤„ç†å™¨
        disruptor.setDefaultExceptionHandler(new PriceEngineExceptionHandler());
    }
    
    // å…¶ä»–æ–¹æ³•æ¡†æ¶...
    public void start() { /* å¯åŠ¨å¼•æ“ */ }
    public void shutdown() { /* å…³é—­å¼•æ“ */ }
    public boolean publishPrice(String symbol, double bid, double ask) { /* å‘å¸ƒä»·æ ¼ */ }
    public EngineStatistics getStatistics() { /* è·å–ç»Ÿè®¡ä¿¡æ¯ */ }
}
```

## ğŸ“š å­¦ä¹ è¦ç‚¹æ€»ç»“

### å…³é”®æŠ€æœ¯æ¦‚å¿µ

1. **Disruptor RingBuffer**: é¢„åˆ†é…çš„ç¯å½¢é˜Ÿåˆ—ï¼Œé¿å…GC
2. **äº‹ä»¶é©±åŠ¨æ¶æ„**: é€šè¿‡äº‹ä»¶ä¼ é€’å®ç°è§£è€¦
3. **å¤„ç†å™¨é“¾æ¨¡å¼**: æµæ°´çº¿å¼çš„äº‹ä»¶å¤„ç†
4. **ç¼“å­˜è¡Œå¯¹é½**: é¿å…false sharingæå‡æ€§èƒ½

### ä¸‹ä¸€æ­¥å­¦ä¹ 

- [é¡¹ç›®2-æ€§èƒ½ä¼˜åŒ–.md](./é¡¹ç›®2-æ€§èƒ½ä¼˜åŒ–.md) - æ·±å…¥æ— é”ç¼–ç¨‹å’ŒCPUä¼˜åŒ–
- [é¡¹ç›®2-æµ‹è¯•éªŒè¯.md](./é¡¹ç›®2-æµ‹è¯•éªŒè¯.md) - JMHåŸºå‡†æµ‹è¯•å®è·µ

### é¢è¯•è¦ç‚¹

- èƒ½å¤Ÿè§£é‡ŠDisruptorçš„å·¥ä½œåŸç†å’Œä¼˜åŠ¿
- ç†è§£æ— é”ç¼–ç¨‹çš„åŸºæœ¬æ¦‚å¿µå’Œåº”ç”¨åœºæ™¯
- æŒæ¡Javaå¹¶å‘ç¼–ç¨‹çš„æœ€ä½³å®è·µ
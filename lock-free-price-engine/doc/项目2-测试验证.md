# é¡¹ç›®2-æµ‹è¯•éªŒè¯: æ€§èƒ½åŸºå‡†æµ‹è¯•ä¸ç³»ç»ŸéªŒè¯

> **å­¦ä¹ ç›®æ ‡**: æŒæ¡é«˜æ€§èƒ½ç³»ç»Ÿçš„æµ‹è¯•æ–¹æ³•å’Œæ€§èƒ½éªŒè¯æŠ€æœ¯  
> **å­¦ä¹ æ—¶é—´**: Day 12-13  
> **æ ¸å¿ƒæŠ€èƒ½**: JMHåŸºå‡†æµ‹è¯•ã€å»¶è¿Ÿåˆ†æã€ååé‡æµ‹è¯•ã€ç³»ç»Ÿç›‘æ§

## ğŸ§ª JMHåŸºå‡†æµ‹è¯•å®ç°

### 1. ç­‰å¾…ç­–ç•¥æ€§èƒ½å¯¹æ¯”æµ‹è¯•

```java
package com.hft.lockfree.benchmark;

import com.hft.lockfree.engine.LockFreePriceEngine;
import com.hft.lockfree.optimization.OptimizedWaitStrategies;
import com.lmax.disruptor.*;
import org.openjdk.jmh.annotations.*;
import org.openjdk.jmh.infra.Blackhole;
import org.openjdk.jmh.runner.Runner;
import org.openjdk.jmh.runner.RunnerException;
import org.openjdk.jmh.runner.options.Options;
import org.openjdk.jmh.runner.options.OptionsBuilder;

import java.util.concurrent.TimeUnit;

/**
 * ç­‰å¾…ç­–ç•¥æ€§èƒ½åŸºå‡†æµ‹è¯•
 * 
 * æµ‹è¯•ç›®æ ‡ï¼š
 * 1. æ¯”è¾ƒä¸åŒç­‰å¾…ç­–ç•¥çš„å»¶è¿Ÿç‰¹æ€§
 * 2. æµ‹é‡ååé‡å·®å¼‚
 * 3. åˆ†æCPUä½¿ç”¨ç‡
 * 4. è¯„ä¼°åŠŸè€—å½±å“
 */
@BenchmarkMode({Mode.AverageTime, Mode.Throughput})
@OutputTimeUnit(TimeUnit.NANOSECONDS)
@State(Scope.Benchmark)
@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)
@Measurement(iterations = 10, time = 2, timeUnit = TimeUnit.SECONDS)
@Fork(value = 1, jvmArgs = {
    "-XX:+UnlockExperimentalVMOptions",
    "-XX:+UseZGC",
    "-XX:+UnlockDiagnosticVMOptions",
    "-XX:+LogVMOutput",
    "-XX:+TraceClassLoading",
    "-Xms4g",
    "-Xmx4g"
})
public class WaitStrategyBenchmark {
    
    @Param({"BusySpinWaitStrategy", "YieldingWaitStrategy", "SleepingWaitStrategy", 
            "BlockingWaitStrategy", "AdaptiveWaitStrategy", "LatencyAwareWaitStrategy"})
    private String waitStrategyName;
    
    @Param({"1024", "4096", "16384", "65536"})
    private int ringBufferSize;
    
    private LockFreePriceEngine engine;
    private RingBuffer<PriceEvent> ringBuffer;
    private EventHandler<PriceEvent> handler;
    private Disruptor<PriceEvent> disruptor;
    
    @Setup(Level.Trial)
    public void setup() {
        WaitStrategy waitStrategy = createWaitStrategy(waitStrategyName);
        
        // åˆ›å»ºäº‹ä»¶å·¥å‚
        EventFactory<PriceEvent> eventFactory = PriceEvent::new;
        
        // åˆ›å»ºDisruptor
        disruptor = new Disruptor<>(eventFactory, ringBufferSize, 
                                   Thread::new, ProducerType.SINGLE, waitStrategy);
        
        // åˆ›å»ºäº‹ä»¶å¤„ç†å™¨
        handler = new LatencyMeasuringHandler();
        disruptor.handleEventsWith(handler);
        
        // å¯åŠ¨Disruptor
        disruptor.start();
        ringBuffer = disruptor.getRingBuffer();
        
        // åˆ›å»ºä»·æ ¼å¼•æ“
        engine = new LockFreePriceEngine.Builder()
                .withRingBufferSize(ringBufferSize)
                .withWaitStrategy(waitStrategy)
                .build();
        
        engine.start();
    }
    
    @TearDown(Level.Trial)
    public void tearDown() {
        if (engine != null) {
            engine.shutdown();
        }
        if (disruptor != null) {
            disruptor.shutdown();
        }
    }
    
    /**
     * æµ‹è¯•å•ä¸ªä»·æ ¼äº‹ä»¶çš„å¤„ç†å»¶è¿Ÿ
     */
    @Benchmark
    public void testSingleEventLatency(Blackhole blackhole) {
        long sequence = ringBuffer.next();
        try {
            PriceEvent event = ringBuffer.get(sequence);
            event.setSymbol("AAPL");
            event.setPrice(150.25);
            event.setQuantity(1000);
            event.setTimestamp(System.nanoTime());
            event.setSide(PriceEvent.Side.BID);
            
            blackhole.consume(event);
        } finally {
            ringBuffer.publish(sequence);
        }
    }
    
    /**
     * æµ‹è¯•æ‰¹é‡äº‹ä»¶å¤„ç†çš„ååé‡
     */
    @Benchmark
    @OperationsPerInvocation(1000)
    public void testBatchThroughput(Blackhole blackhole) {
        for (int i = 0; i < 1000; i++) {
            long sequence = ringBuffer.next();
            try {
                PriceEvent event = ringBuffer.get(sequence);
                event.setSymbol("AAPL");
                event.setPrice(150.25 + (i % 100) * 0.01);
                event.setQuantity(1000 + i);
                event.setTimestamp(System.nanoTime());
                event.setSide(i % 2 == 0 ? PriceEvent.Side.BID : PriceEvent.Side.ASK);
                
                blackhole.consume(event);
            } finally {
                ringBuffer.publish(sequence);
            }
        }
    }
    
    /**
     * æµ‹è¯•é«˜å¹¶å‘åœºæ™¯ä¸‹çš„æ€§èƒ½
     */
    @Benchmark
    @Threads(4)
    public void testConcurrentAccess(Blackhole blackhole) {
        engine.updatePrice("AAPL", 150.25, 1000, PriceEvent.Side.BID);
        blackhole.consume(engine.getBestBid("AAPL"));
    }
    
    /**
     * åˆ›å»ºæŒ‡å®šç±»å‹çš„ç­‰å¾…ç­–ç•¥
     */
    private WaitStrategy createWaitStrategy(String strategyName) {
        switch (strategyName) {
            case "BusySpinWaitStrategy":
                return new BusySpinWaitStrategy();
            case "YieldingWaitStrategy":
                return new YieldingWaitStrategy();
            case "SleepingWaitStrategy":
                return new SleepingWaitStrategy();
            case "BlockingWaitStrategy":
                return new BlockingWaitStrategy();
            case "AdaptiveWaitStrategy":
                return new OptimizedWaitStrategies.AdaptiveWaitStrategy();
            case "LatencyAwareWaitStrategy":
                return new OptimizedWaitStrategies.LatencyAwareWaitStrategy(10_000); // 10Î¼s
            default:
                throw new IllegalArgumentException("Unknown wait strategy: " + strategyName);
        }
    }
    
    /**
     * å»¶è¿Ÿæµ‹é‡äº‹ä»¶å¤„ç†å™¨
     */
    private static class LatencyMeasuringHandler implements EventHandler<PriceEvent> {
        private long totalLatency = 0;
        private long eventCount = 0;
        
        @Override
        public void onEvent(PriceEvent event, long sequence, boolean endOfBatch) {
            long currentTime = System.nanoTime();
            long latency = currentTime - event.getTimestamp();
            
            totalLatency += latency;
            eventCount++;
            
            // æ¯1000ä¸ªäº‹ä»¶è¾“å‡ºä¸€æ¬¡ç»Ÿè®¡
            if (eventCount % 1000 == 0) {
                double avgLatency = (double) totalLatency / eventCount;
                System.out.printf("Avg latency: %.2f ns (%.2f Î¼s)%n", 
                                avgLatency, avgLatency / 1000.0);
            }
        }
        
        public double getAverageLatency() {
            return eventCount > 0 ? (double) totalLatency / eventCount : 0.0;
        }
        
        public void reset() {
            totalLatency = 0;
            eventCount = 0;
        }
    }
    
    /**
     * è¿è¡ŒåŸºå‡†æµ‹è¯•
     */
    public static void main(String[] args) throws RunnerException {
        Options opt = new OptionsBuilder()
                .include(WaitStrategyBenchmark.class.getSimpleName())
                .result("wait-strategy-benchmark-results.json")
                .resultFormat(org.openjdk.jmh.results.format.ResultFormatType.JSON)
                .build();
        
        new Runner(opt).run();
    }
}
```

### 2. å»¶è¿Ÿåˆ†å¸ƒåˆ†ææµ‹è¯•

```java
package com.hft.lockfree.benchmark;

import com.hft.lockfree.engine.LockFreePriceEngine;
import org.HdrHistogram.Histogram;
import org.openjdk.jmh.annotations.*;
import org.openjdk.jmh.infra.Blackhole;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;

/**
 * å»¶è¿Ÿåˆ†å¸ƒåˆ†ææµ‹è¯•
 * 
 * ä½¿ç”¨HdrHistogramè¿›è¡Œç²¾ç¡®çš„å»¶è¿Ÿæµ‹é‡å’Œåˆ†æ
 */
@BenchmarkMode(Mode.SingleShotTime)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
@State(Scope.Benchmark)
@Warmup(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)
@Measurement(iterations = 5, time = 5, timeUnit = TimeUnit.SECONDS)
public class LatencyDistributionBenchmark {
    
    private static final int OPERATIONS_COUNT = 1_000_000;
    private static final long MAX_LATENCY_NS = TimeUnit.SECONDS.toNanos(1); // 1ç§’æœ€å¤§å»¶è¿Ÿ
    
    private LockFreePriceEngine engine;
    private Histogram latencyHistogram;
    private AtomicLong operationCounter;
    
    @Setup(Level.Trial)
    public void setup() {
        engine = new LockFreePriceEngine.Builder()
                .withRingBufferSize(65536)
                .withWaitStrategy(new BusySpinWaitStrategy())
                .enableLatencyTracking(true)
                .build();
        
        engine.start();
        
        // åˆ›å»ºHdrHistogramï¼Œç²¾åº¦ä¸º3ä½æœ‰æ•ˆæ•°å­—
        latencyHistogram = new Histogram(MAX_LATENCY_NS, 3);
        operationCounter = new AtomicLong(0);
    }
    
    @TearDown(Level.Trial)
    public void tearDown() {
        if (engine != null) {
            engine.shutdown();
        }
        
        // è¾“å‡ºå»¶è¿Ÿåˆ†å¸ƒç»Ÿè®¡
        printLatencyStatistics();
    }
    
    /**
     * æµ‹è¯•ä»·æ ¼æ›´æ–°çš„ç«¯åˆ°ç«¯å»¶è¿Ÿ
     */
    @Benchmark
    @OperationsPerInvocation(OPERATIONS_COUNT)
    public void testEndToEndLatency(Blackhole blackhole) {
        for (int i = 0; i < OPERATIONS_COUNT; i++) {
            long startTime = System.nanoTime();
            
            // æ‰§è¡Œä»·æ ¼æ›´æ–°æ“ä½œ
            engine.updatePrice("AAPL", 150.0 + (i % 100) * 0.01, 1000 + i, 
                             i % 2 == 0 ? PriceEvent.Side.BID : PriceEvent.Side.ASK);
            
            // è·å–æœ€æ–°ä»·æ ¼ï¼ˆæ¨¡æ‹Ÿå®Œæ•´çš„å¤„ç†æµç¨‹ï¼‰
            double bestPrice = i % 2 == 0 ? engine.getBestBid("AAPL") : engine.getBestAsk("AAPL");
            
            long endTime = System.nanoTime();
            long latency = endTime - startTime;
            
            // è®°å½•å»¶è¿Ÿ
            latencyHistogram.recordValue(latency);
            operationCounter.incrementAndGet();
            
            blackhole.consume(bestPrice);
        }
    }
    
    /**
     * æµ‹è¯•ä¸åŒè´Ÿè½½ä¸‹çš„å»¶è¿Ÿç‰¹æ€§
     */
    @Benchmark
    @Param({"1", "10", "100", "1000"})
    public void testLatencyUnderLoad(int loadFactor, Blackhole blackhole) {
        for (int i = 0; i < loadFactor; i++) {
            long startTime = System.nanoTime();
            
            engine.updatePrice("SYMBOL_" + (i % 10), 100.0 + i * 0.01, 1000, PriceEvent.Side.BID);
            
            long endTime = System.nanoTime();
            latencyHistogram.recordValue(endTime - startTime);
            
            blackhole.consume(engine.getBestBid("SYMBOL_" + (i % 10)));
        }
    }
    
    /**
     * è¾“å‡ºè¯¦ç»†çš„å»¶è¿Ÿç»Ÿè®¡ä¿¡æ¯
     */
    private void printLatencyStatistics() {
        System.out.println("\n=== å»¶è¿Ÿåˆ†å¸ƒç»Ÿè®¡ ===");
        System.out.printf("æ€»æ“ä½œæ•°: %,d%n", latencyHistogram.getTotalCount());
        System.out.printf("æœ€å°å»¶è¿Ÿ: %,d ns (%.2f Î¼s)%n", 
                         latencyHistogram.getMinValue(), 
                         latencyHistogram.getMinValue() / 1000.0);
        System.out.printf("æœ€å¤§å»¶è¿Ÿ: %,d ns (%.2f Î¼s)%n", 
                         latencyHistogram.getMaxValue(), 
                         latencyHistogram.getMaxValue() / 1000.0);
        System.out.printf("å¹³å‡å»¶è¿Ÿ: %.2f ns (%.2f Î¼s)%n", 
                         latencyHistogram.getMean(), 
                         latencyHistogram.getMean() / 1000.0);
        
        System.out.println("\n=== ç™¾åˆ†ä½å»¶è¿Ÿ ===");
        double[] percentiles = {50.0, 90.0, 95.0, 99.0, 99.9, 99.99, 99.999};
        for (double percentile : percentiles) {
            long latencyAtPercentile = latencyHistogram.getValueAtPercentile(percentile);
            System.out.printf("P%.3f: %,d ns (%.2f Î¼s)%n", 
                             percentile, latencyAtPercentile, latencyAtPercentile / 1000.0);
        }
        
        System.out.println("\n=== å»¶è¿Ÿåˆ†å¸ƒç›´æ–¹å›¾ ===");
        latencyHistogram.outputPercentileDistribution(System.out, 1000.0); // è¾“å‡ºå¾®ç§’å•ä½
    }
    
    /**
     * è·å–å½“å‰å»¶è¿Ÿç»Ÿè®¡å¿«ç…§
     */
    public LatencySnapshot getLatencySnapshot() {
        return new LatencySnapshot(
            latencyHistogram.getTotalCount(),
            latencyHistogram.getMinValue(),
            latencyHistogram.getMaxValue(),
            latencyHistogram.getMean(),
            latencyHistogram.getValueAtPercentile(50.0),
            latencyHistogram.getValueAtPercentile(95.0),
            latencyHistogram.getValueAtPercentile(99.0),
            latencyHistogram.getValueAtPercentile(99.9)
        );
    }
    
    /**
     * å»¶è¿Ÿå¿«ç…§æ•°æ®ç±»
     */
    public static class LatencySnapshot {
        private final long totalCount;
        private final long minLatency;
        private final long maxLatency;
        private final double meanLatency;
        private final long p50Latency;
        private final long p95Latency;
        private final long p99Latency;
        private final long p999Latency;
        
        public LatencySnapshot(long totalCount, long minLatency, long maxLatency, 
                             double meanLatency, long p50Latency, long p95Latency, 
                             long p99Latency, long p999Latency) {
            this.totalCount = totalCount;
            this.minLatency = minLatency;
            this.maxLatency = maxLatency;
            this.meanLatency = meanLatency;
            this.p50Latency = p50Latency;
            this.p95Latency = p95Latency;
            this.p99Latency = p99Latency;
            this.p999Latency = p999Latency;
        }
        
        // Getters
        public long getTotalCount() { return totalCount; }
        public long getMinLatency() { return minLatency; }
        public long getMaxLatency() { return maxLatency; }
        public double getMeanLatency() { return meanLatency; }
        public long getP50Latency() { return p50Latency; }
        public long getP95Latency() { return p95Latency; }
        public long getP99Latency() { return p99Latency; }
        public long getP999Latency() { return p999Latency; }
        
        /**
         * æ£€æŸ¥æ˜¯å¦æ»¡è¶³å»¶è¿Ÿè¦æ±‚
         */
        public boolean meetsLatencyRequirements() {
            return p99Latency <= 10_000 && // P99 < 10Î¼s
                   p999Latency <= 50_000 && // P99.9 < 50Î¼s
                   meanLatency <= 5_000;    // å¹³å‡ < 5Î¼s
        }
        
        @Override
        public String toString() {
            return String.format(
                "LatencySnapshot{count=%d, min=%.2fÎ¼s, max=%.2fÎ¼s, mean=%.2fÎ¼s, " +
                "p50=%.2fÎ¼s, p95=%.2fÎ¼s, p99=%.2fÎ¼s, p999=%.2fÎ¼s}",
                totalCount,
                minLatency / 1000.0, maxLatency / 1000.0, meanLatency / 1000.0,
                p50Latency / 1000.0, p95Latency / 1000.0, 
                p99Latency / 1000.0, p999Latency / 1000.0
            );
        }
    }
}
```

### 3. å‹åŠ›æµ‹è¯•å’Œç¨³å®šæ€§éªŒè¯

```java
package com.hft.lockfree.test;

import com.hft.lockfree.engine.LockFreePriceEngine;
import org.junit.jupiter.api.*;
import org.junit.jupiter.api.parallel.Execution;
import org.junit.jupiter.api.parallel.ExecutionMode;

import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;

/**
 * å‹åŠ›æµ‹è¯•å’Œç¨³å®šæ€§éªŒè¯
 * 
 * æµ‹è¯•åœºæ™¯ï¼š
 * 1. é•¿æ—¶é—´è¿è¡Œç¨³å®šæ€§
 * 2. é«˜å¹¶å‘å‹åŠ›æµ‹è¯•
 * 3. å†…å­˜æ³„æ¼æ£€æµ‹
 * 4. å¼‚å¸¸æ¢å¤èƒ½åŠ›
 */
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
@Execution(ExecutionMode.CONCURRENT)
public class StressAndStabilityTest {
    
    private static final int THREAD_COUNT = Runtime.getRuntime().availableProcessors();
    private static final int TEST_DURATION_SECONDS = 60;
    private static final int OPERATIONS_PER_SECOND = 100_000;
    
    private LockFreePriceEngine engine;
    private ExecutorService executorService;
    
    @BeforeEach
    void setUp() {
        engine = new LockFreePriceEngine.Builder()
                .withRingBufferSize(65536)
                .withWaitStrategy(new BusySpinWaitStrategy())
                .enableMetrics(true)
                .build();
        
        engine.start();
        
        executorService = Executors.newFixedThreadPool(THREAD_COUNT);
    }
    
    @AfterEach
    void tearDown() {
        if (executorService != null) {
            executorService.shutdown();
            try {
                if (!executorService.awaitTermination(5, TimeUnit.SECONDS)) {
                    executorService.shutdownNow();
                }
            } catch (InterruptedException e) {
                executorService.shutdownNow();
            }
        }
        
        if (engine != null) {
            engine.shutdown();
        }
    }
    
    /**
     * é«˜å¹¶å‘å‹åŠ›æµ‹è¯•
     */
    @Test
    @Order(1)
    @Timeout(value = TEST_DURATION_SECONDS + 10, unit = TimeUnit.SECONDS)
    void testHighConcurrencyStress() throws InterruptedException {
        System.out.println("å¼€å§‹é«˜å¹¶å‘å‹åŠ›æµ‹è¯•...");
        
        AtomicLong operationCount = new AtomicLong(0);
        AtomicLong errorCount = new AtomicLong(0);
        AtomicReference<Exception> lastError = new AtomicReference<>();
        
        CountDownLatch startLatch = new CountDownLatch(1);
        CountDownLatch finishLatch = new CountDownLatch(THREAD_COUNT);
        
        // å¯åŠ¨å¤šä¸ªç”Ÿäº§è€…çº¿ç¨‹
        for (int i = 0; i < THREAD_COUNT; i++) {
            final int threadId = i;
            executorService.submit(() -> {
                try {
                    startLatch.await();
                    
                    long endTime = System.currentTimeMillis() + TEST_DURATION_SECONDS * 1000L;
                    int operationsPerThread = OPERATIONS_PER_SECOND / THREAD_COUNT;
                    long sleepInterval = 1000L / operationsPerThread; // æ¯«ç§’
                    
                    while (System.currentTimeMillis() < endTime) {
                        try {
                            // æ‰§è¡Œä»·æ ¼æ›´æ–°æ“ä½œ
                            String symbol = "SYMBOL_" + (threadId % 10);
                            double price = 100.0 + Math.random() * 50.0;
                            long quantity = 1000 + (long)(Math.random() * 9000);
                            PriceEvent.Side side = Math.random() > 0.5 ? 
                                                 PriceEvent.Side.BID : PriceEvent.Side.ASK;
                            
                            engine.updatePrice(symbol, price, quantity, side);
                            operationCount.incrementAndGet();
                            
                            // æ§åˆ¶æ“ä½œé¢‘ç‡
                            if (sleepInterval > 0) {
                                Thread.sleep(sleepInterval);
                            }
                            
                        } catch (Exception e) {
                            errorCount.incrementAndGet();
                            lastError.set(e);
                        }
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } finally {
                    finishLatch.countDown();
                }
            });
        }
        
        // å¼€å§‹æµ‹è¯•
        long startTime = System.currentTimeMillis();
        startLatch.countDown();
        
        // ç­‰å¾…æµ‹è¯•å®Œæˆ
        finishLatch.await();
        long endTime = System.currentTimeMillis();
        
        // è¾“å‡ºæµ‹è¯•ç»“æœ
        long totalOperations = operationCount.get();
        long totalErrors = errorCount.get();
        double duration = (endTime - startTime) / 1000.0;
        double throughput = totalOperations / duration;
        
        System.out.printf("å‹åŠ›æµ‹è¯•å®Œæˆ:%n");
        System.out.printf("  æµ‹è¯•æ—¶é•¿: %.2f ç§’%n", duration);
        System.out.printf("  æ€»æ“ä½œæ•°: %,d%n", totalOperations);
        System.out.printf("  é”™è¯¯æ•°é‡: %,d%n", totalErrors);
        System.out.printf("  ååé‡: %,.0f ops/sec%n", throughput);
        System.out.printf("  é”™è¯¯ç‡: %.4f%%%n", (double) totalErrors / totalOperations * 100);
        
        // éªŒè¯ç»“æœ
        Assertions.assertTrue(totalOperations > 0, "åº”è¯¥æœ‰æ“ä½œè¢«æ‰§è¡Œ");
        Assertions.assertTrue(totalErrors < totalOperations * 0.01, 
                            "é”™è¯¯ç‡åº”è¯¥å°äº1%ï¼Œå®é™…: " + (double) totalErrors / totalOperations * 100 + "%");
        Assertions.assertTrue(throughput >= OPERATIONS_PER_SECOND * 0.8, 
                            "ååé‡åº”è¯¥è¾¾åˆ°ç›®æ ‡çš„80%ä»¥ä¸Š");
        
        if (lastError.get() != null) {
            System.err.println("æœ€åä¸€ä¸ªé”™è¯¯: " + lastError.get().getMessage());
        }
    }
    
    /**
     * é•¿æ—¶é—´è¿è¡Œç¨³å®šæ€§æµ‹è¯•
     */
    @Test
    @Order(2)
    @Timeout(value = 300, unit = TimeUnit.SECONDS) // 5åˆ†é’Ÿè¶…æ—¶
    void testLongRunningStability() throws InterruptedException {
        System.out.println("å¼€å§‹é•¿æ—¶é—´ç¨³å®šæ€§æµ‹è¯•...");
        
        AtomicLong totalOperations = new AtomicLong(0);
        AtomicLong memoryUsageMB = new AtomicLong(0);
        
        // å†…å­˜ç›‘æ§çº¿ç¨‹
        Thread memoryMonitor = new Thread(() -> {
            while (!Thread.currentThread().isInterrupted()) {
                Runtime runtime = Runtime.getRuntime();
                long usedMemory = (runtime.totalMemory() - runtime.freeMemory()) / 1024 / 1024;
                memoryUsageMB.set(usedMemory);
                
                try {
                    Thread.sleep(1000); // æ¯ç§’æ£€æŸ¥ä¸€æ¬¡
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        });
        
        memoryMonitor.start();
        
        // è¿è¡Œæµ‹è¯•
        long testDuration = 120_000; // 2åˆ†é’Ÿ
        long endTime = System.currentTimeMillis() + testDuration;
        long initialMemory = memoryUsageMB.get();
        
        while (System.currentTimeMillis() < endTime) {
            // æ‰§è¡Œæ“ä½œ
            for (int i = 0; i < 1000; i++) {
                engine.updatePrice("STABILITY_TEST", 100.0 + Math.random(), 
                                 1000, PriceEvent.Side.BID);
                totalOperations.incrementAndGet();
            }
            
            // æ£€æŸ¥å†…å­˜ä½¿ç”¨
            long currentMemory = memoryUsageMB.get();
            if (currentMemory > initialMemory + 500) { // å†…å­˜å¢é•¿è¶…è¿‡500MB
                Assertions.fail("æ£€æµ‹åˆ°å¯èƒ½çš„å†…å­˜æ³„æ¼ï¼Œå†…å­˜ä½¿ç”¨ä» " + initialMemory + 
                              "MB å¢é•¿åˆ° " + currentMemory + "MB");
            }
            
            Thread.sleep(100); // çŸ­æš‚ä¼‘æ¯
        }
        
        memoryMonitor.interrupt();
        
        System.out.printf("ç¨³å®šæ€§æµ‹è¯•å®Œæˆ:%n");
        System.out.printf("  æ€»æ“ä½œæ•°: %,d%n", totalOperations.get());
        System.out.printf("  åˆå§‹å†…å­˜: %d MB%n", initialMemory);
        System.out.printf("  æœ€ç»ˆå†…å­˜: %d MB%n", memoryUsageMB.get());
        System.out.printf("  å†…å­˜å¢é•¿: %d MB%n", memoryUsageMB.get() - initialMemory);
        
        // éªŒè¯ç¨³å®šæ€§
        Assertions.assertTrue(totalOperations.get() > 100_000, "åº”è¯¥æ‰§è¡Œè¶³å¤Ÿå¤šçš„æ“ä½œ");
        Assertions.assertTrue(memoryUsageMB.get() - initialMemory < 200, 
                            "å†…å­˜å¢é•¿åº”è¯¥æ§åˆ¶åœ¨200MBä»¥å†…");
    }
    
    /**
     * å¼‚å¸¸æ¢å¤èƒ½åŠ›æµ‹è¯•
     */
    @Test
    @Order(3)
    void testExceptionRecovery() throws InterruptedException {
        System.out.println("å¼€å§‹å¼‚å¸¸æ¢å¤æµ‹è¯•...");
        
        AtomicLong successCount = new AtomicLong(0);
        AtomicLong exceptionCount = new AtomicLong(0);
        
        // æ¨¡æ‹Ÿå„ç§å¼‚å¸¸æƒ…å†µ
        for (int i = 0; i < 10000; i++) {
            try {
                if (i % 1000 == 0) {
                    // æ¨¡æ‹Ÿæ— æ•ˆè¾“å…¥
                    engine.updatePrice(null, Double.NaN, -1, null);
                } else if (i % 500 == 0) {
                    // æ¨¡æ‹Ÿæç«¯å€¼
                    engine.updatePrice("TEST", Double.MAX_VALUE, Long.MAX_VALUE, PriceEvent.Side.BID);
                } else {
                    // æ­£å¸¸æ“ä½œ
                    engine.updatePrice("TEST", 100.0 + i * 0.01, 1000 + i, 
                                     i % 2 == 0 ? PriceEvent.Side.BID : PriceEvent.Side.ASK);
                    successCount.incrementAndGet();
                }
            } catch (Exception e) {
                exceptionCount.incrementAndGet();
                // éªŒè¯ç³»ç»Ÿä»ç„¶å¯ä»¥ç»§ç»­å·¥ä½œ
                try {
                    engine.updatePrice("RECOVERY_TEST", 100.0, 1000, PriceEvent.Side.BID);
                    successCount.incrementAndGet();
                } catch (Exception recoveryException) {
                    Assertions.fail("ç³»ç»Ÿåœ¨å¼‚å¸¸åæ— æ³•æ¢å¤: " + recoveryException.getMessage());
                }
            }
        }
        
        System.out.printf("å¼‚å¸¸æ¢å¤æµ‹è¯•å®Œæˆ:%n");
        System.out.printf("  æˆåŠŸæ“ä½œ: %,d%n", successCount.get());
        System.out.printf("  å¼‚å¸¸æ¬¡æ•°: %,d%n", exceptionCount.get());
        
        // éªŒè¯ç³»ç»Ÿçš„å¥å£®æ€§
        Assertions.assertTrue(successCount.get() > 8000, "å¤§éƒ¨åˆ†æ“ä½œåº”è¯¥æˆåŠŸ");
        Assertions.assertTrue(exceptionCount.get() > 0, "åº”è¯¥æ•è·åˆ°ä¸€äº›å¼‚å¸¸");
        
        // éªŒè¯ç³»ç»Ÿæœ€ç»ˆçŠ¶æ€æ­£å¸¸
        double bestBid = engine.getBestBid("TEST");
        Assertions.assertTrue(bestBid > 0, "ç³»ç»Ÿåº”è¯¥ä»ç„¶å¯ä»¥æ­£å¸¸å·¥ä½œ");
    }
}
```

## ğŸ“Š æ€§èƒ½éªŒè¯æ ‡å‡†

### å»¶è¿Ÿè¦æ±‚éªŒè¯

```java
/**
 * æ€§èƒ½éªŒè¯å·¥å…·ç±»
 */
public class PerformanceValidator {
    
    private static final long TARGET_P99_LATENCY_NS = 10_000; // 10Î¼s
    private static final long TARGET_P999_LATENCY_NS = 50_000; // 50Î¼s
    private static final double TARGET_THROUGHPUT_OPS = 1_000_000; // 1M TPS
    
    /**
     * éªŒè¯å»¶è¿Ÿè¦æ±‚
     */
    public static boolean validateLatencyRequirements(LatencySnapshot snapshot) {
        boolean p99Met = snapshot.getP99Latency() <= TARGET_P99_LATENCY_NS;
        boolean p999Met = snapshot.getP999Latency() <= TARGET_P999_LATENCY_NS;
        
        System.out.printf("å»¶è¿ŸéªŒè¯ç»“æœ:%n");
        System.out.printf("  P99å»¶è¿Ÿ: %.2fÎ¼s (ç›®æ ‡: %.2fÎ¼s) %s%n",
                         snapshot.getP99Latency() / 1000.0,
                         TARGET_P99_LATENCY_NS / 1000.0,
                         p99Met ? "âœ“" : "âœ—");
        System.out.printf("  P99.9å»¶è¿Ÿ: %.2fÎ¼s (ç›®æ ‡: %.2fÎ¼s) %s%n",
                         snapshot.getP999Latency() / 1000.0,
                         TARGET_P999_LATENCY_NS / 1000.0,
                         p999Met ? "âœ“" : "âœ—");
        
        return p99Met && p999Met;
    }
    
    /**
     * éªŒè¯ååé‡è¦æ±‚
     */
    public static boolean validateThroughputRequirements(double actualThroughput) {
        boolean throughputMet = actualThroughput >= TARGET_THROUGHPUT_OPS;
        
        System.out.printf("ååé‡éªŒè¯ç»“æœ:%n");
        System.out.printf("  å®é™…ååé‡: %,.0f ops/sec%n", actualThroughput);
        System.out.printf("  ç›®æ ‡ååé‡: %,.0f ops/sec%n", TARGET_THROUGHPUT_OPS);
        System.out.printf("  è¾¾æˆç‡: %.1f%% %s%n",
                         (actualThroughput / TARGET_THROUGHPUT_OPS) * 100,
                         throughputMet ? "âœ“" : "âœ—");
        
        return throughputMet;
    }
}
```

## ğŸ¯ æµ‹è¯•éªŒè¯æ£€æŸ¥æ¸…å•

### åŠŸèƒ½æµ‹è¯•

- [ ] **åŸºæœ¬åŠŸèƒ½**: ä»·æ ¼æ›´æ–°ã€æŸ¥è¯¢ã€äº‹ä»¶å¤„ç†
- [ ] **è¾¹ç•Œæ¡ä»¶**: æå€¼å¤„ç†ã€ç©ºå€¼å¤„ç†ã€å¼‚å¸¸è¾“å…¥
- [ ] **å¹¶å‘å®‰å…¨**: å¤šçº¿ç¨‹è®¿é—®ã€æ•°æ®ä¸€è‡´æ€§
- [ ] **å†…å­˜ç®¡ç†**: æ— å†…å­˜æ³„æ¼ã€GCå‹åŠ›æ§åˆ¶

### æ€§èƒ½æµ‹è¯•

- [ ] **å»¶è¿Ÿæµ‹è¯•**: P99 < 10Î¼s, P99.9 < 50Î¼s
- [ ] **ååé‡æµ‹è¯•**: > 1M TPS
- [ ] **å‹åŠ›æµ‹è¯•**: é•¿æ—¶é—´ç¨³å®šè¿è¡Œ
- [ ] **èµ„æºä½¿ç”¨**: CPUã€å†…å­˜ã€ç½‘ç»œæ•ˆç‡

### ç¨³å®šæ€§æµ‹è¯•

- [ ] **å¼‚å¸¸æ¢å¤**: ç³»ç»Ÿå¼‚å¸¸åèƒ½æ­£å¸¸æ¢å¤
- [ ] **èµ„æºæ³„æ¼**: æ— å†…å­˜ã€æ–‡ä»¶å¥æŸ„æ³„æ¼
- [ ] **è´Ÿè½½é€‚åº”**: ä¸åŒè´Ÿè½½ä¸‹æ€§èƒ½è¡¨ç°
- [ ] **æ•…éšœæ³¨å…¥**: æ¨¡æ‹Ÿå„ç§æ•…éšœåœºæ™¯

## ğŸ“š å­¦ä¹ è¦ç‚¹æ€»ç»“

### æµ‹è¯•æŠ€èƒ½æŒæ¡

1. **JMHåŸºå‡†æµ‹è¯•**: å‡†ç¡®æµ‹é‡å¾®åŸºå‡†æ€§èƒ½
2. **HdrHistogram**: ç²¾ç¡®çš„å»¶è¿Ÿåˆ†å¸ƒåˆ†æ
3. **å‹åŠ›æµ‹è¯•**: éªŒè¯ç³»ç»Ÿåœ¨é«˜è´Ÿè½½ä¸‹çš„è¡¨ç°
4. **ç¨³å®šæ€§æµ‹è¯•**: ç¡®ä¿é•¿æœŸè¿è¡Œçš„å¯é æ€§

### ä¸‹ä¸€æ­¥å­¦ä¹ 

- [é¡¹ç›®2-é¢è¯•å‡†å¤‡.md](./é¡¹ç›®2-é¢è¯•å‡†å¤‡.md) - é¢è¯•è¦ç‚¹å’ŒæŠ€æœ¯æ€»ç»“

### é¢è¯•è¦ç‚¹

- èƒ½å¤Ÿè®¾è®¡å’Œå®æ–½å…¨é¢çš„æ€§èƒ½æµ‹è¯•æ–¹æ¡ˆ
- ç†è§£ä¸åŒæµ‹è¯•æ–¹æ³•çš„é€‚ç”¨åœºæ™¯å’Œå±€é™æ€§
- æŒæ¡æ€§èƒ½é—®é¢˜çš„è¯Šæ–­å’Œä¼˜åŒ–æ–¹æ³•
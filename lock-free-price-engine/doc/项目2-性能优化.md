# 项目2-性能优化: 无锁编程与CPU级优化技术

> **学习目标**: 掌握高级性能优化技术，实现微秒级延迟目标  
> **学习时间**: Day 8-11  
> **核心技能**: 无锁编程、CPU亲和性、内存优化、NUMA感知

## 🚀 无锁编程深度实践

### 1. CPU亲和性优化实现

```java
package com.hft.lockfree.optimization;

import net.openhft.affinity.Affinity;
import net.openhft.affinity.AffinityLock;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.BitSet;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * CPU亲和性管理器
 * 
 * 功能：
 * 1. 线程绑定到特定CPU核心
 * 2. 避免线程迁移开销
 * 3. 提升缓存局部性
 * 4. 减少上下文切换
 */
public class CpuAffinityManager {
    
    private static final Logger logger = LoggerFactory.getLogger(CpuAffinityManager.class);
    
    private final BitSet availableCpus;
    private final AtomicInteger nextCpuIndex = new AtomicInteger(0);
    
    public CpuAffinityManager() {
        this.availableCpus = Affinity.getAffinity();
        logger.info("Available CPUs: {}", availableCpus);
        logger.info("CPU count: {}", availableCpus.cardinality());
    }
    
    /**
     * 创建具有CPU亲和性的线程工厂
     */
    public ThreadFactory createAffinityThreadFactory(String namePrefix) {
        return new AffinityThreadFactory(namePrefix);
    }
    
    /**
     * 为当前线程设置CPU亲和性
     */
    public AffinityLock bindCurrentThread() {
        int cpuId = getNextAvailableCpu();
        AffinityLock lock = AffinityLock.acquireLock(cpuId);
        
        logger.info("Thread {} bound to CPU {}", Thread.currentThread().getName(), cpuId);
        return lock;
    }
    
    /**
     * 获取下一个可用的CPU核心
     */
    private int getNextAvailableCpu() {
        int cpuCount = availableCpus.cardinality();
        if (cpuCount == 0) {
            throw new IllegalStateException("No available CPUs");
        }
        
        int index = nextCpuIndex.getAndIncrement() % cpuCount;
        int cpuId = 0;
        
        // 找到第index个设置的位
        for (int i = 0; i <= index; i++) {
            cpuId = availableCpus.nextSetBit(cpuId);
            if (i < index) {
                cpuId++;
            }
        }
        
        return cpuId;
    }
    
    /**
     * 具有CPU亲和性的线程工厂
     */
    private class AffinityThreadFactory implements ThreadFactory {
        private final String namePrefix;
        private final AtomicInteger threadNumber = new AtomicInteger(1);
        
        public AffinityThreadFactory(String namePrefix) {
            this.namePrefix = namePrefix;
        }
        
        @Override
        public Thread newThread(Runnable r) {
            Thread thread = new Thread(() -> {
                // 绑定CPU
                AffinityLock lock = bindCurrentThread();
                try {
                    r.run();
                } finally {
                    lock.release();
                }
            });
            
            thread.setName(namePrefix + "-" + threadNumber.getAndIncrement());
            thread.setDaemon(false);
            thread.setPriority(Thread.MAX_PRIORITY);
            
            return thread;
        }
    }
    
    /**
     * 获取CPU拓扑信息
     */
    public CpuTopology getCpuTopology() {
        return new CpuTopology();
    }
    
    /**
     * CPU拓扑信息
     */
    public static class CpuTopology {
        private final int physicalCores;
        private final int logicalCores;
        private final boolean hyperthreadingEnabled;
        
        public CpuTopology() {
            this.logicalCores = Runtime.getRuntime().availableProcessors();
            this.physicalCores = getPhysicalCoreCount();
            this.hyperthreadingEnabled = logicalCores > physicalCores;
        }
        
        private int getPhysicalCoreCount() {
            // 简化实现，实际应该读取/proc/cpuinfo或使用JNI
            return logicalCores / (isHyperthreadingLikelyEnabled() ? 2 : 1);
        }
        
        private boolean isHyperthreadingLikelyEnabled() {
            // 启发式判断：如果逻辑核心数是物理核心数的2倍，可能启用了超线程
            return logicalCores % 2 == 0 && logicalCores > 2;
        }
        
        public int getPhysicalCores() { return physicalCores; }
        public int getLogicalCores() { return logicalCores; }
        public boolean isHyperthreadingEnabled() { return hyperthreadingEnabled; }
        
        @Override
        public String toString() {
            return String.format("CpuTopology{physical=%d, logical=%d, hyperthreading=%s}",
                               physicalCores, logicalCores, hyperthreadingEnabled);
        }
    }
}
```

### 2. 内存屏障与缓存优化

```java
package com.hft.lockfree.optimization;

import sun.misc.Unsafe;
import java.lang.reflect.Field;

/**
 * 内存屏障和缓存优化工具类
 * 
 * 提供：
 * 1. 内存屏障操作
 * 2. 缓存行对齐
 * 3. False sharing避免
 * 4. 内存预取
 */
public class MemoryOptimizer {
    
    private static final Unsafe UNSAFE;
    private static final int CACHE_LINE_SIZE = 64; // 大多数现代CPU的缓存行大小
    
    static {
        try {
            Field field = Unsafe.class.getDeclaredField("theUnsafe");
            field.setAccessible(true);
            UNSAFE = (Unsafe) field.get(null);
        } catch (Exception e) {
            throw new RuntimeException("Unable to access Unsafe", e);
        }
    }
    
    /**
     * 强制内存屏障，确保内存操作的顺序性
     */
    public static void fullMemoryBarrier() {
        UNSAFE.fullFence();
    }
    
    /**
     * 加载屏障，确保读操作的顺序性
     */
    public static void loadFence() {
        UNSAFE.loadFence();
    }
    
    /**
     * 存储屏障，确保写操作的顺序性
     */
    public static void storeFence() {
        UNSAFE.storeFence();
    }
    
    /**
     * 缓存行对齐的长整型数组
     * 避免false sharing
     */
    public static class CacheLineAlignedLong {
        // 前填充
        private long p1, p2, p3, p4, p5, p6, p7;
        
        // 实际数据
        private volatile long value;
        
        // 后填充
        private long p8, p9, p10, p11, p12, p13, p14;
        
        public CacheLineAlignedLong(long initialValue) {
            this.value = initialValue;
        }
        
        public long get() {
            return value;
        }
        
        public void set(long newValue) {
            this.value = newValue;
        }
        
        public boolean compareAndSet(long expected, long update) {
            return UNSAFE.compareAndSwapLong(this, VALUE_OFFSET, expected, update);
        }
        
        public long getAndIncrement() {
            return UNSAFE.getAndAddLong(this, VALUE_OFFSET, 1L);
        }
        
        public long incrementAndGet() {
            return UNSAFE.getAndAddLong(this, VALUE_OFFSET, 1L) + 1L;
        }
        
        private static final long VALUE_OFFSET;
        
        static {
            try {
                VALUE_OFFSET = UNSAFE.objectFieldOffset(
                    CacheLineAlignedLong.class.getDeclaredField("value"));
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    }
    
    /**
     * 内存预取工具
     */
    public static class MemoryPrefetcher {
        
        /**
         * 预取内存地址，提升缓存命中率
         */
        public static void prefetch(Object obj, long offset) {
            // 使用Unsafe进行内存预取
            // 注意：这是平台相关的优化
            long address = UNSAFE.objectFieldOffset(obj.getClass().getDeclaredFields()[0]) + offset;
            prefetchMemory(address);
        }
        
        /**
         * 预取连续内存区域
         */
        public static void prefetchRange(long startAddress, int length) {
            for (long addr = startAddress; addr < startAddress + length; addr += CACHE_LINE_SIZE) {
                prefetchMemory(addr);
            }
        }
        
        private static void prefetchMemory(long address) {
            // 实际的预取实现依赖于具体的CPU架构
            // 这里提供一个通用的实现框架
            try {
                // 通过读取内存来触发预取
                UNSAFE.getByte(address);
            } catch (Exception e) {
                // 忽略预取失败
            }
        }
    }
    
    /**
     * NUMA感知的内存分配器
     */
    public static class NumaAwareAllocator {
        
        /**
         * 在指定NUMA节点上分配内存
         */
        public static long allocateOnNode(int nodeId, long size) {
            // 简化实现，实际需要调用系统API
            long address = UNSAFE.allocateMemory(size);
            
            // 在实际实现中，这里应该调用numa_alloc_onnode()
            // 或类似的系统调用来确保内存分配在指定节点
            
            return address;
        }
        
        /**
         * 获取当前线程的NUMA节点
         */
        public static int getCurrentNumaNode() {
            // 简化实现，实际需要调用系统API
            // 在Linux上可以通过/proc/self/numa_maps获取
            return 0; // 默认返回节点0
        }
        
        /**
         * 将内存页面绑定到特定NUMA节点
         */
        public static void bindToNode(long address, long size, int nodeId) {
            // 实际实现需要调用mbind()系统调用
            // 这里提供接口框架
        }
    }
}
```

### 3. 高性能等待策略实现

```java
package com.hft.lockfree.optimization;

import com.lmax.disruptor.AlertException;
import com.lmax.disruptor.Sequence;
import com.lmax.disruptor.SequenceBarrier;
import com.lmax.disruptor.WaitStrategy;

/**
 * 自定义等待策略实现
 * 
 * 提供多种等待策略的优化实现：
 * 1. 自适应等待策略
 * 2. 混合等待策略
 * 3. 延迟感知等待策略
 */
public class OptimizedWaitStrategies {
    
    /**
     * 自适应等待策略
     * 根据系统负载动态调整等待行为
     */
    public static class AdaptiveWaitStrategy implements WaitStrategy {
        
        private static final int SPIN_TRIES = 10000;
        private static final int YIELD_TRIES = 1000;
        
        private volatile long spinCount = 0;
        private volatile long yieldCount = 0;
        private volatile long blockCount = 0;
        
        @Override
        public long waitFor(long sequence, Sequence cursor, Sequence dependentSequence, 
                          SequenceBarrier barrier) throws AlertException, InterruptedException {
            
            long availableSequence;
            int counter = SPIN_TRIES;
            
            // 第一阶段：忙等待
            while ((availableSequence = dependentSequence.get()) < sequence && counter > 0) {
                counter--;
                spinCount++;
                barrier.checkAlert();
            }
            
            // 第二阶段：让步等待
            counter = YIELD_TRIES;
            while ((availableSequence = dependentSequence.get()) < sequence && counter > 0) {
                counter--;
                yieldCount++;
                Thread.yield();
                barrier.checkAlert();
            }
            
            // 第三阶段：阻塞等待
            while ((availableSequence = dependentSequence.get()) < sequence) {
                blockCount++;
                barrier.checkAlert();
                
                synchronized (this) {
                    wait(1); // 短暂等待
                }
            }
            
            return availableSequence;
        }
        
        @Override
        public void signalAllWhenBlocking() {
            synchronized (this) {
                notifyAll();
            }
        }
        
        public WaitStatistics getStatistics() {
            return new WaitStatistics(spinCount, yieldCount, blockCount);
        }
        
        public void resetStatistics() {
            spinCount = 0;
            yieldCount = 0;
            blockCount = 0;
        }
    }
    
    /**
     * 延迟感知等待策略
     * 根据延迟要求调整等待行为
     */
    public static class LatencyAwareWaitStrategy implements WaitStrategy {
        
        private final long maxLatencyNanos;
        private final WaitStrategy lowLatencyStrategy;
        private final WaitStrategy highThroughputStrategy;
        
        public LatencyAwareWaitStrategy(long maxLatencyNanos) {
            this.maxLatencyNanos = maxLatencyNanos;
            this.lowLatencyStrategy = new BusySpinWaitStrategy();
            this.highThroughputStrategy = new YieldingWaitStrategy();
        }
        
        @Override
        public long waitFor(long sequence, Sequence cursor, Sequence dependentSequence, 
                          SequenceBarrier barrier) throws AlertException, InterruptedException {
            
            long startTime = System.nanoTime();
            
            // 首先尝试低延迟策略
            try {
                return lowLatencyStrategy.waitFor(sequence, cursor, dependentSequence, barrier);
            } catch (Exception e) {
                // 如果低延迟策略失败或超时，切换到高吞吐量策略
                long elapsed = System.nanoTime() - startTime;
                if (elapsed > maxLatencyNanos) {
                    return highThroughputStrategy.waitFor(sequence, cursor, dependentSequence, barrier);
                }
                throw e;
            }
        }
        
        @Override
        public void signalAllWhenBlocking() {
            lowLatencyStrategy.signalAllWhenBlocking();
            highThroughputStrategy.signalAllWhenBlocking();
        }
    }
    
    /**
     * 忙等待策略的优化实现
     */
    public static class BusySpinWaitStrategy implements WaitStrategy {
        
        @Override
        public long waitFor(long sequence, Sequence cursor, Sequence dependentSequence, 
                          SequenceBarrier barrier) throws AlertException {
            
            long availableSequence;
            
            while ((availableSequence = dependentSequence.get()) < sequence) {
                barrier.checkAlert();
                // CPU pause指令，减少功耗和热量
                Thread.onSpinWait();
            }
            
            return availableSequence;
        }
        
        @Override
        public void signalAllWhenBlocking() {
            // 忙等待策略不需要信号通知
        }
    }
    
    /**
     * 让步等待策略的优化实现
     */
    public static class YieldingWaitStrategy implements WaitStrategy {
        
        private static final int SPIN_TRIES = 100;
        
        @Override
        public long waitFor(long sequence, Sequence cursor, Sequence dependentSequence, 
                          SequenceBarrier barrier) throws AlertException {
            
            long availableSequence;
            int counter = SPIN_TRIES;
            
            // 先进行短暂的忙等待
            while ((availableSequence = dependentSequence.get()) < sequence && counter > 0) {
                counter--;
                barrier.checkAlert();
                Thread.onSpinWait();
            }
            
            // 然后进行让步等待
            while ((availableSequence = dependentSequence.get()) < sequence) {
                barrier.checkAlert();
                Thread.yield();
            }
            
            return availableSequence;
        }
        
        @Override
        public void signalAllWhenBlocking() {
            // 让步等待策略不需要信号通知
        }
    }
    
    /**
     * 等待策略统计信息
     */
    public static class WaitStatistics {
        private final long spinCount;
        private final long yieldCount;
        private final long blockCount;
        
        public WaitStatistics(long spinCount, long yieldCount, long blockCount) {
            this.spinCount = spinCount;
            this.yieldCount = yieldCount;
            this.blockCount = blockCount;
        }
        
        public long getSpinCount() { return spinCount; }
        public long getYieldCount() { return yieldCount; }
        public long getBlockCount() { return blockCount; }
        public long getTotalWaits() { return spinCount + yieldCount + blockCount; }
        
        public double getSpinRatio() {
            long total = getTotalWaits();
            return total > 0 ? (double) spinCount / total : 0.0;
        }
        
        public double getYieldRatio() {
            long total = getTotalWaits();
            return total > 0 ? (double) yieldCount / total : 0.0;
        }
        
        public double getBlockRatio() {
            long total = getTotalWaits();
            return total > 0 ? (double) blockCount / total : 0.0;
        }
        
        @Override
        public String toString() {
            return String.format("WaitStats{spin=%d(%.1f%%), yield=%d(%.1f%%), block=%d(%.1f%%)}",
                               spinCount, getSpinRatio() * 100,
                               yieldCount, getYieldRatio() * 100,
                               blockCount, getBlockRatio() * 100);
        }
    }
}
```

### 4. 无锁数据结构实现

```java
package com.hft.lockfree.datastructure;

import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicLong;

/**
 * 无锁价格簿实现
 * 
 * 特性：
 * 1. 完全无锁的价格存储
 * 2. 支持并发读写
 * 3. 内存高效
 * 4. 低延迟访问
 */
public class LockFreePriceBook {
    
    /**
     * 价格层级节点
     */
    private static class PriceLevel {
        final double price;
        volatile long quantity;
        volatile PriceLevel next;
        volatile long timestamp;
        
        PriceLevel(double price, long quantity) {
            this.price = price;
            this.quantity = quantity;
            this.timestamp = System.nanoTime();
        }
        
        PriceLevel(double price, long quantity, PriceLevel next) {
            this(price, quantity);
            this.next = next;
        }
    }
    
    private final AtomicReference<PriceLevel> bidHead = new AtomicReference<>();
    private final AtomicReference<PriceLevel> askHead = new AtomicReference<>();
    private final AtomicLong version = new AtomicLong(0);
    
    /**
     * 添加买单价格层级
     */
    public boolean addBid(double price, long quantity) {
        return addPriceLevel(bidHead, price, quantity, true);
    }
    
    /**
     * 添加卖单价格层级
     */
    public boolean addAsk(double price, long quantity) {
        return addPriceLevel(askHead, price, quantity, false);
    }
    
    /**
     * 无锁添加价格层级
     */
    private boolean addPriceLevel(AtomicReference<PriceLevel> head, double price, long quantity, boolean isBid) {
        while (true) {
            PriceLevel currentHead = head.get();
            
            // 检查是否应该插入到头部
            if (shouldInsertAtHead(currentHead, price, isBid)) {
                PriceLevel newLevel = new PriceLevel(price, quantity, currentHead);
                if (head.compareAndSet(currentHead, newLevel)) {
                    version.incrementAndGet();
                    return true;
                }
                // CAS失败，重试
                continue;
            }
            
            // 需要插入到中间或末尾
            return insertInOrder(currentHead, price, quantity, isBid);
        }
    }
    
    /**
     * 判断是否应该插入到头部
     */
    private boolean shouldInsertAtHead(PriceLevel head, double price, boolean isBid) {
        if (head == null) {
            return true;
        }
        
        if (isBid) {
            // 买单：价格高的在前
            return price > head.price;
        } else {
            // 卖单：价格低的在前
            return price < head.price;
        }
    }
    
    /**
     * 按顺序插入价格层级
     */
    private boolean insertInOrder(PriceLevel head, double price, long quantity, boolean isBid) {
        PriceLevel current = head;
        
        while (current != null) {
            PriceLevel next = current.next;
            
            // 检查是否找到插入位置
            if (shouldInsertBetween(current, next, price, isBid)) {
                PriceLevel newLevel = new PriceLevel(price, quantity, next);
                
                // 使用CAS更新next指针
                if (compareAndSetNext(current, next, newLevel)) {
                    version.incrementAndGet();
                    return true;
                }
                // CAS失败，重新开始
                return false;
            }
            
            // 检查是否是相同价格（更新数量）
            if (current.price == price) {
                return updateQuantity(current, quantity);
            }
            
            current = next;
        }
        
        return false;
    }
    
    /**
     * 判断是否应该在两个节点之间插入
     */
    private boolean shouldInsertBetween(PriceLevel current, PriceLevel next, double price, boolean isBid) {
        if (next == null) {
            return true; // 插入到末尾
        }
        
        if (isBid) {
            return current.price > price && price > next.price;
        } else {
            return current.price < price && price < next.price;
        }
    }
    
    /**
     * 原子性更新next指针
     */
    private boolean compareAndSetNext(PriceLevel node, PriceLevel expected, PriceLevel update) {
        // 使用Unsafe进行CAS操作
        return UNSAFE.compareAndSwapObject(node, NEXT_OFFSET, expected, update);
    }
    
    /**
     * 原子性更新数量
     */
    private boolean updateQuantity(PriceLevel level, long newQuantity) {
        // 使用CAS更新数量
        long currentQuantity = level.quantity;
        if (UNSAFE.compareAndSwapLong(level, QUANTITY_OFFSET, currentQuantity, newQuantity)) {
            level.timestamp = System.nanoTime();
            version.incrementAndGet();
            return true;
        }
        return false;
    }
    
    /**
     * 获取最优买价
     */
    public double getBestBid() {
        PriceLevel head = bidHead.get();
        return head != null ? head.price : 0.0;
    }
    
    /**
     * 获取最优卖价
     */
    public double getBestAsk() {
        PriceLevel head = askHead.get();
        return head != null ? head.price : 0.0;
    }
    
    /**
     * 获取价差
     */
    public double getSpread() {
        return getBestAsk() - getBestBid();
    }
    
    /**
     * 获取版本号（用于检测变化）
     */
    public long getVersion() {
        return version.get();
    }
    
    /**
     * 获取价格簿快照
     */
    public PriceBookSnapshot getSnapshot() {
        long snapshotVersion = version.get();
        PriceLevel bidSnapshot = copyPriceLevels(bidHead.get());
        PriceLevel askSnapshot = copyPriceLevels(askHead.get());
        
        return new PriceBookSnapshot(snapshotVersion, bidSnapshot, askSnapshot);
    }
    
    /**
     * 复制价格层级链表
     */
    private PriceLevel copyPriceLevels(PriceLevel head) {
        if (head == null) {
            return null;
        }
        
        PriceLevel copy = new PriceLevel(head.price, head.quantity);
        copy.timestamp = head.timestamp;
        copy.next = copyPriceLevels(head.next);
        
        return copy;
    }
    
    // Unsafe相关的静态字段和初始化
    private static final sun.misc.Unsafe UNSAFE;
    private static final long NEXT_OFFSET;
    private static final long QUANTITY_OFFSET;
    
    static {
        try {
            java.lang.reflect.Field field = sun.misc.Unsafe.class.getDeclaredField("theUnsafe");
            field.setAccessible(true);
            UNSAFE = (sun.misc.Unsafe) field.get(null);
            
            NEXT_OFFSET = UNSAFE.objectFieldOffset(PriceLevel.class.getDeclaredField("next"));
            QUANTITY_OFFSET = UNSAFE.objectFieldOffset(PriceLevel.class.getDeclaredField("quantity"));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
    
    /**
     * 价格簿快照
     */
    public static class PriceBookSnapshot {
        private final long version;
        private final PriceLevel bidLevels;
        private final PriceLevel askLevels;
        
        public PriceBookSnapshot(long version, PriceLevel bidLevels, PriceLevel askLevels) {
            this.version = version;
            this.bidLevels = bidLevels;
            this.askLevels = askLevels;
        }
        
        public long getVersion() { return version; }
        public PriceLevel getBidLevels() { return bidLevels; }
        public PriceLevel getAskLevels() { return askLevels; }
    }
}
```

## 🎯 性能优化检查清单

### CPU级优化

- [ ] **线程亲和性**: 绑定关键线程到特定CPU核心
- [ ] **NUMA感知**: 内存分配在正确的NUMA节点
- [ ] **超线程优化**: 避免关键线程共享物理核心
- [ ] **中断亲和性**: 网络中断绑定到非关键CPU

### 内存级优化

- [ ] **缓存行对齐**: 避免false sharing
- [ ] **内存预取**: 提前加载可能访问的数据
- [ ] **内存屏障**: 确保内存操作的正确顺序
- [ ] **堆外内存**: 减少GC压力

### 并发级优化

- [ ] **无锁数据结构**: 消除锁竞争
- [ ] **等待策略优化**: 选择合适的等待策略
- [ ] **批处理**: 减少系统调用开销
- [ ] **事件驱动**: 避免轮询开销

## 📚 学习要点总结

### 关键性能概念

1. **CPU亲和性**: 减少线程迁移和缓存失效
2. **内存屏障**: 确保多线程环境下的内存一致性
3. **无锁编程**: 使用CAS操作避免锁竞争
4. **缓存优化**: 提升内存访问效率

### 下一步学习

- [项目2-测试验证.md](./项目2-测试验证.md) - 性能测试和验证
- [项目2-面试准备.md](./项目2-面试准备.md) - 面试要点总结

### 面试要点

- 能够解释无锁编程的原理和应用场景
- 理解CPU缓存和内存层次结构
- 掌握Java并发编程的高级技术
# é¡¹ç›®2-æ€§èƒ½ä¼˜åŒ–: æ— é”ç¼–ç¨‹ä¸CPUçº§ä¼˜åŒ–æŠ€æœ¯

> **å­¦ä¹ ç›®æ ‡**: æŒæ¡é«˜çº§æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯ï¼Œå®ç°å¾®ç§’çº§å»¶è¿Ÿç›®æ ‡  
> **å­¦ä¹ æ—¶é—´**: Day 8-11  
> **æ ¸å¿ƒæŠ€èƒ½**: æ— é”ç¼–ç¨‹ã€CPUäº²å’Œæ€§ã€å†…å­˜ä¼˜åŒ–ã€NUMAæ„ŸçŸ¥

## ğŸš€ æ— é”ç¼–ç¨‹æ·±åº¦å®è·µ

### 1. CPUäº²å’Œæ€§ä¼˜åŒ–å®ç°

```java
package com.hft.lockfree.optimization;

import net.openhft.affinity.Affinity;
import net.openhft.affinity.AffinityLock;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.BitSet;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * CPUäº²å’Œæ€§ç®¡ç†å™¨
 * 
 * åŠŸèƒ½ï¼š
 * 1. çº¿ç¨‹ç»‘å®šåˆ°ç‰¹å®šCPUæ ¸å¿ƒ
 * 2. é¿å…çº¿ç¨‹è¿ç§»å¼€é”€
 * 3. æå‡ç¼“å­˜å±€éƒ¨æ€§
 * 4. å‡å°‘ä¸Šä¸‹æ–‡åˆ‡æ¢
 */
public class CpuAffinityManager {
    
    private static final Logger logger = LoggerFactory.getLogger(CpuAffinityManager.class);
    
    private final BitSet availableCpus;
    private final AtomicInteger nextCpuIndex = new AtomicInteger(0);
    
    public CpuAffinityManager() {
        this.availableCpus = Affinity.getAffinity();
        logger.info("Available CPUs: {}", availableCpus);
        logger.info("CPU count: {}", availableCpus.cardinality());
    }
    
    /**
     * åˆ›å»ºå…·æœ‰CPUäº²å’Œæ€§çš„çº¿ç¨‹å·¥å‚
     */
    public ThreadFactory createAffinityThreadFactory(String namePrefix) {
        return new AffinityThreadFactory(namePrefix);
    }
    
    /**
     * ä¸ºå½“å‰çº¿ç¨‹è®¾ç½®CPUäº²å’Œæ€§
     */
    public AffinityLock bindCurrentThread() {
        int cpuId = getNextAvailableCpu();
        AffinityLock lock = AffinityLock.acquireLock(cpuId);
        
        logger.info("Thread {} bound to CPU {}", Thread.currentThread().getName(), cpuId);
        return lock;
    }
    
    /**
     * è·å–ä¸‹ä¸€ä¸ªå¯ç”¨çš„CPUæ ¸å¿ƒ
     */
    private int getNextAvailableCpu() {
        int cpuCount = availableCpus.cardinality();
        if (cpuCount == 0) {
            throw new IllegalStateException("No available CPUs");
        }
        
        int index = nextCpuIndex.getAndIncrement() % cpuCount;
        int cpuId = 0;
        
        // æ‰¾åˆ°ç¬¬indexä¸ªè®¾ç½®çš„ä½
        for (int i = 0; i <= index; i++) {
            cpuId = availableCpus.nextSetBit(cpuId);
            if (i < index) {
                cpuId++;
            }
        }
        
        return cpuId;
    }
    
    /**
     * å…·æœ‰CPUäº²å’Œæ€§çš„çº¿ç¨‹å·¥å‚
     */
    private class AffinityThreadFactory implements ThreadFactory {
        private final String namePrefix;
        private final AtomicInteger threadNumber = new AtomicInteger(1);
        
        public AffinityThreadFactory(String namePrefix) {
            this.namePrefix = namePrefix;
        }
        
        @Override
        public Thread newThread(Runnable r) {
            Thread thread = new Thread(() -> {
                // ç»‘å®šCPU
                AffinityLock lock = bindCurrentThread();
                try {
                    r.run();
                } finally {
                    lock.release();
                }
            });
            
            thread.setName(namePrefix + "-" + threadNumber.getAndIncrement());
            thread.setDaemon(false);
            thread.setPriority(Thread.MAX_PRIORITY);
            
            return thread;
        }
    }
    
    /**
     * è·å–CPUæ‹“æ‰‘ä¿¡æ¯
     */
    public CpuTopology getCpuTopology() {
        return new CpuTopology();
    }
    
    /**
     * CPUæ‹“æ‰‘ä¿¡æ¯
     */
    public static class CpuTopology {
        private final int physicalCores;
        private final int logicalCores;
        private final boolean hyperthreadingEnabled;
        
        public CpuTopology() {
            this.logicalCores = Runtime.getRuntime().availableProcessors();
            this.physicalCores = getPhysicalCoreCount();
            this.hyperthreadingEnabled = logicalCores > physicalCores;
        }
        
        private int getPhysicalCoreCount() {
            // ç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥è¯»å–/proc/cpuinfoæˆ–ä½¿ç”¨JNI
            return logicalCores / (isHyperthreadingLikelyEnabled() ? 2 : 1);
        }
        
        private boolean isHyperthreadingLikelyEnabled() {
            // å¯å‘å¼åˆ¤æ–­ï¼šå¦‚æœé€»è¾‘æ ¸å¿ƒæ•°æ˜¯ç‰©ç†æ ¸å¿ƒæ•°çš„2å€ï¼Œå¯èƒ½å¯ç”¨äº†è¶…çº¿ç¨‹
            return logicalCores % 2 == 0 && logicalCores > 2;
        }
        
        public int getPhysicalCores() { return physicalCores; }
        public int getLogicalCores() { return logicalCores; }
        public boolean isHyperthreadingEnabled() { return hyperthreadingEnabled; }
        
        @Override
        public String toString() {
            return String.format("CpuTopology{physical=%d, logical=%d, hyperthreading=%s}",
                               physicalCores, logicalCores, hyperthreadingEnabled);
        }
    }
}
```

### 2. å†…å­˜å±éšœä¸ç¼“å­˜ä¼˜åŒ–

```java
package com.hft.lockfree.optimization;

import sun.misc.Unsafe;
import java.lang.reflect.Field;

/**
 * å†…å­˜å±éšœå’Œç¼“å­˜ä¼˜åŒ–å·¥å…·ç±»
 * 
 * æä¾›ï¼š
 * 1. å†…å­˜å±éšœæ“ä½œ
 * 2. ç¼“å­˜è¡Œå¯¹é½
 * 3. False sharingé¿å…
 * 4. å†…å­˜é¢„å–
 */
public class MemoryOptimizer {
    
    private static final Unsafe UNSAFE;
    private static final int CACHE_LINE_SIZE = 64; // å¤§å¤šæ•°ç°ä»£CPUçš„ç¼“å­˜è¡Œå¤§å°
    
    static {
        try {
            Field field = Unsafe.class.getDeclaredField("theUnsafe");
            field.setAccessible(true);
            UNSAFE = (Unsafe) field.get(null);
        } catch (Exception e) {
            throw new RuntimeException("Unable to access Unsafe", e);
        }
    }
    
    /**
     * å¼ºåˆ¶å†…å­˜å±éšœï¼Œç¡®ä¿å†…å­˜æ“ä½œçš„é¡ºåºæ€§
     */
    public static void fullMemoryBarrier() {
        UNSAFE.fullFence();
    }
    
    /**
     * åŠ è½½å±éšœï¼Œç¡®ä¿è¯»æ“ä½œçš„é¡ºåºæ€§
     */
    public static void loadFence() {
        UNSAFE.loadFence();
    }
    
    /**
     * å­˜å‚¨å±éšœï¼Œç¡®ä¿å†™æ“ä½œçš„é¡ºåºæ€§
     */
    public static void storeFence() {
        UNSAFE.storeFence();
    }
    
    /**
     * ç¼“å­˜è¡Œå¯¹é½çš„é•¿æ•´å‹æ•°ç»„
     * é¿å…false sharing
     */
    public static class CacheLineAlignedLong {
        // å‰å¡«å……
        private long p1, p2, p3, p4, p5, p6, p7;
        
        // å®é™…æ•°æ®
        private volatile long value;
        
        // åå¡«å……
        private long p8, p9, p10, p11, p12, p13, p14;
        
        public CacheLineAlignedLong(long initialValue) {
            this.value = initialValue;
        }
        
        public long get() {
            return value;
        }
        
        public void set(long newValue) {
            this.value = newValue;
        }
        
        public boolean compareAndSet(long expected, long update) {
            return UNSAFE.compareAndSwapLong(this, VALUE_OFFSET, expected, update);
        }
        
        public long getAndIncrement() {
            return UNSAFE.getAndAddLong(this, VALUE_OFFSET, 1L);
        }
        
        public long incrementAndGet() {
            return UNSAFE.getAndAddLong(this, VALUE_OFFSET, 1L) + 1L;
        }
        
        private static final long VALUE_OFFSET;
        
        static {
            try {
                VALUE_OFFSET = UNSAFE.objectFieldOffset(
                    CacheLineAlignedLong.class.getDeclaredField("value"));
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    }
    
    /**
     * å†…å­˜é¢„å–å·¥å…·
     */
    public static class MemoryPrefetcher {
        
        /**
         * é¢„å–å†…å­˜åœ°å€ï¼Œæå‡ç¼“å­˜å‘½ä¸­ç‡
         */
        public static void prefetch(Object obj, long offset) {
            // ä½¿ç”¨Unsafeè¿›è¡Œå†…å­˜é¢„å–
            // æ³¨æ„ï¼šè¿™æ˜¯å¹³å°ç›¸å…³çš„ä¼˜åŒ–
            long address = UNSAFE.objectFieldOffset(obj.getClass().getDeclaredFields()[0]) + offset;
            prefetchMemory(address);
        }
        
        /**
         * é¢„å–è¿ç»­å†…å­˜åŒºåŸŸ
         */
        public static void prefetchRange(long startAddress, int length) {
            for (long addr = startAddress; addr < startAddress + length; addr += CACHE_LINE_SIZE) {
                prefetchMemory(addr);
            }
        }
        
        private static void prefetchMemory(long address) {
            // å®é™…çš„é¢„å–å®ç°ä¾èµ–äºå…·ä½“çš„CPUæ¶æ„
            // è¿™é‡Œæä¾›ä¸€ä¸ªé€šç”¨çš„å®ç°æ¡†æ¶
            try {
                // é€šè¿‡è¯»å–å†…å­˜æ¥è§¦å‘é¢„å–
                UNSAFE.getByte(address);
            } catch (Exception e) {
                // å¿½ç•¥é¢„å–å¤±è´¥
            }
        }
    }
    
    /**
     * NUMAæ„ŸçŸ¥çš„å†…å­˜åˆ†é…å™¨
     */
    public static class NumaAwareAllocator {
        
        /**
         * åœ¨æŒ‡å®šNUMAèŠ‚ç‚¹ä¸Šåˆ†é…å†…å­˜
         */
        public static long allocateOnNode(int nodeId, long size) {
            // ç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦è°ƒç”¨ç³»ç»ŸAPI
            long address = UNSAFE.allocateMemory(size);
            
            // åœ¨å®é™…å®ç°ä¸­ï¼Œè¿™é‡Œåº”è¯¥è°ƒç”¨numa_alloc_onnode()
            // æˆ–ç±»ä¼¼çš„ç³»ç»Ÿè°ƒç”¨æ¥ç¡®ä¿å†…å­˜åˆ†é…åœ¨æŒ‡å®šèŠ‚ç‚¹
            
            return address;
        }
        
        /**
         * è·å–å½“å‰çº¿ç¨‹çš„NUMAèŠ‚ç‚¹
         */
        public static int getCurrentNumaNode() {
            // ç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦è°ƒç”¨ç³»ç»ŸAPI
            // åœ¨Linuxä¸Šå¯ä»¥é€šè¿‡/proc/self/numa_mapsè·å–
            return 0; // é»˜è®¤è¿”å›èŠ‚ç‚¹0
        }
        
        /**
         * å°†å†…å­˜é¡µé¢ç»‘å®šåˆ°ç‰¹å®šNUMAèŠ‚ç‚¹
         */
        public static void bindToNode(long address, long size, int nodeId) {
            // å®é™…å®ç°éœ€è¦è°ƒç”¨mbind()ç³»ç»Ÿè°ƒç”¨
            // è¿™é‡Œæä¾›æ¥å£æ¡†æ¶
        }
    }
}
```

### 3. é«˜æ€§èƒ½ç­‰å¾…ç­–ç•¥å®ç°

```java
package com.hft.lockfree.optimization;

import com.lmax.disruptor.AlertException;
import com.lmax.disruptor.Sequence;
import com.lmax.disruptor.SequenceBarrier;
import com.lmax.disruptor.WaitStrategy;

/**
 * è‡ªå®šä¹‰ç­‰å¾…ç­–ç•¥å®ç°
 * 
 * æä¾›å¤šç§ç­‰å¾…ç­–ç•¥çš„ä¼˜åŒ–å®ç°ï¼š
 * 1. è‡ªé€‚åº”ç­‰å¾…ç­–ç•¥
 * 2. æ··åˆç­‰å¾…ç­–ç•¥
 * 3. å»¶è¿Ÿæ„ŸçŸ¥ç­‰å¾…ç­–ç•¥
 */
public class OptimizedWaitStrategies {
    
    /**
     * è‡ªé€‚åº”ç­‰å¾…ç­–ç•¥
     * æ ¹æ®ç³»ç»Ÿè´Ÿè½½åŠ¨æ€è°ƒæ•´ç­‰å¾…è¡Œä¸º
     */
    public static class AdaptiveWaitStrategy implements WaitStrategy {
        
        private static final int SPIN_TRIES = 10000;
        private static final int YIELD_TRIES = 1000;
        
        private volatile long spinCount = 0;
        private volatile long yieldCount = 0;
        private volatile long blockCount = 0;
        
        @Override
        public long waitFor(long sequence, Sequence cursor, Sequence dependentSequence, 
                          SequenceBarrier barrier) throws AlertException, InterruptedException {
            
            long availableSequence;
            int counter = SPIN_TRIES;
            
            // ç¬¬ä¸€é˜¶æ®µï¼šå¿™ç­‰å¾…
            while ((availableSequence = dependentSequence.get()) < sequence && counter > 0) {
                counter--;
                spinCount++;
                barrier.checkAlert();
            }
            
            // ç¬¬äºŒé˜¶æ®µï¼šè®©æ­¥ç­‰å¾…
            counter = YIELD_TRIES;
            while ((availableSequence = dependentSequence.get()) < sequence && counter > 0) {
                counter--;
                yieldCount++;
                Thread.yield();
                barrier.checkAlert();
            }
            
            // ç¬¬ä¸‰é˜¶æ®µï¼šé˜»å¡ç­‰å¾…
            while ((availableSequence = dependentSequence.get()) < sequence) {
                blockCount++;
                barrier.checkAlert();
                
                synchronized (this) {
                    wait(1); // çŸ­æš‚ç­‰å¾…
                }
            }
            
            return availableSequence;
        }
        
        @Override
        public void signalAllWhenBlocking() {
            synchronized (this) {
                notifyAll();
            }
        }
        
        public WaitStatistics getStatistics() {
            return new WaitStatistics(spinCount, yieldCount, blockCount);
        }
        
        public void resetStatistics() {
            spinCount = 0;
            yieldCount = 0;
            blockCount = 0;
        }
    }
    
    /**
     * å»¶è¿Ÿæ„ŸçŸ¥ç­‰å¾…ç­–ç•¥
     * æ ¹æ®å»¶è¿Ÿè¦æ±‚è°ƒæ•´ç­‰å¾…è¡Œä¸º
     */
    public static class LatencyAwareWaitStrategy implements WaitStrategy {
        
        private final long maxLatencyNanos;
        private final WaitStrategy lowLatencyStrategy;
        private final WaitStrategy highThroughputStrategy;
        
        public LatencyAwareWaitStrategy(long maxLatencyNanos) {
            this.maxLatencyNanos = maxLatencyNanos;
            this.lowLatencyStrategy = new BusySpinWaitStrategy();
            this.highThroughputStrategy = new YieldingWaitStrategy();
        }
        
        @Override
        public long waitFor(long sequence, Sequence cursor, Sequence dependentSequence, 
                          SequenceBarrier barrier) throws AlertException, InterruptedException {
            
            long startTime = System.nanoTime();
            
            // é¦–å…ˆå°è¯•ä½å»¶è¿Ÿç­–ç•¥
            try {
                return lowLatencyStrategy.waitFor(sequence, cursor, dependentSequence, barrier);
            } catch (Exception e) {
                // å¦‚æœä½å»¶è¿Ÿç­–ç•¥å¤±è´¥æˆ–è¶…æ—¶ï¼Œåˆ‡æ¢åˆ°é«˜ååé‡ç­–ç•¥
                long elapsed = System.nanoTime() - startTime;
                if (elapsed > maxLatencyNanos) {
                    return highThroughputStrategy.waitFor(sequence, cursor, dependentSequence, barrier);
                }
                throw e;
            }
        }
        
        @Override
        public void signalAllWhenBlocking() {
            lowLatencyStrategy.signalAllWhenBlocking();
            highThroughputStrategy.signalAllWhenBlocking();
        }
    }
    
    /**
     * å¿™ç­‰å¾…ç­–ç•¥çš„ä¼˜åŒ–å®ç°
     */
    public static class BusySpinWaitStrategy implements WaitStrategy {
        
        @Override
        public long waitFor(long sequence, Sequence cursor, Sequence dependentSequence, 
                          SequenceBarrier barrier) throws AlertException {
            
            long availableSequence;
            
            while ((availableSequence = dependentSequence.get()) < sequence) {
                barrier.checkAlert();
                // CPU pauseæŒ‡ä»¤ï¼Œå‡å°‘åŠŸè€—å’Œçƒ­é‡
                Thread.onSpinWait();
            }
            
            return availableSequence;
        }
        
        @Override
        public void signalAllWhenBlocking() {
            // å¿™ç­‰å¾…ç­–ç•¥ä¸éœ€è¦ä¿¡å·é€šçŸ¥
        }
    }
    
    /**
     * è®©æ­¥ç­‰å¾…ç­–ç•¥çš„ä¼˜åŒ–å®ç°
     */
    public static class YieldingWaitStrategy implements WaitStrategy {
        
        private static final int SPIN_TRIES = 100;
        
        @Override
        public long waitFor(long sequence, Sequence cursor, Sequence dependentSequence, 
                          SequenceBarrier barrier) throws AlertException {
            
            long availableSequence;
            int counter = SPIN_TRIES;
            
            // å…ˆè¿›è¡ŒçŸ­æš‚çš„å¿™ç­‰å¾…
            while ((availableSequence = dependentSequence.get()) < sequence && counter > 0) {
                counter--;
                barrier.checkAlert();
                Thread.onSpinWait();
            }
            
            // ç„¶åè¿›è¡Œè®©æ­¥ç­‰å¾…
            while ((availableSequence = dependentSequence.get()) < sequence) {
                barrier.checkAlert();
                Thread.yield();
            }
            
            return availableSequence;
        }
        
        @Override
        public void signalAllWhenBlocking() {
            // è®©æ­¥ç­‰å¾…ç­–ç•¥ä¸éœ€è¦ä¿¡å·é€šçŸ¥
        }
    }
    
    /**
     * ç­‰å¾…ç­–ç•¥ç»Ÿè®¡ä¿¡æ¯
     */
    public static class WaitStatistics {
        private final long spinCount;
        private final long yieldCount;
        private final long blockCount;
        
        public WaitStatistics(long spinCount, long yieldCount, long blockCount) {
            this.spinCount = spinCount;
            this.yieldCount = yieldCount;
            this.blockCount = blockCount;
        }
        
        public long getSpinCount() { return spinCount; }
        public long getYieldCount() { return yieldCount; }
        public long getBlockCount() { return blockCount; }
        public long getTotalWaits() { return spinCount + yieldCount + blockCount; }
        
        public double getSpinRatio() {
            long total = getTotalWaits();
            return total > 0 ? (double) spinCount / total : 0.0;
        }
        
        public double getYieldRatio() {
            long total = getTotalWaits();
            return total > 0 ? (double) yieldCount / total : 0.0;
        }
        
        public double getBlockRatio() {
            long total = getTotalWaits();
            return total > 0 ? (double) blockCount / total : 0.0;
        }
        
        @Override
        public String toString() {
            return String.format("WaitStats{spin=%d(%.1f%%), yield=%d(%.1f%%), block=%d(%.1f%%)}",
                               spinCount, getSpinRatio() * 100,
                               yieldCount, getYieldRatio() * 100,
                               blockCount, getBlockRatio() * 100);
        }
    }
}
```

### 4. æ— é”æ•°æ®ç»“æ„å®ç°

```java
package com.hft.lockfree.datastructure;

import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicLong;

/**
 * æ— é”ä»·æ ¼ç°¿å®ç°
 * 
 * ç‰¹æ€§ï¼š
 * 1. å®Œå…¨æ— é”çš„ä»·æ ¼å­˜å‚¨
 * 2. æ”¯æŒå¹¶å‘è¯»å†™
 * 3. å†…å­˜é«˜æ•ˆ
 * 4. ä½å»¶è¿Ÿè®¿é—®
 */
public class LockFreePriceBook {
    
    /**
     * ä»·æ ¼å±‚çº§èŠ‚ç‚¹
     */
    private static class PriceLevel {
        final double price;
        volatile long quantity;
        volatile PriceLevel next;
        volatile long timestamp;
        
        PriceLevel(double price, long quantity) {
            this.price = price;
            this.quantity = quantity;
            this.timestamp = System.nanoTime();
        }
        
        PriceLevel(double price, long quantity, PriceLevel next) {
            this(price, quantity);
            this.next = next;
        }
    }
    
    private final AtomicReference<PriceLevel> bidHead = new AtomicReference<>();
    private final AtomicReference<PriceLevel> askHead = new AtomicReference<>();
    private final AtomicLong version = new AtomicLong(0);
    
    /**
     * æ·»åŠ ä¹°å•ä»·æ ¼å±‚çº§
     */
    public boolean addBid(double price, long quantity) {
        return addPriceLevel(bidHead, price, quantity, true);
    }
    
    /**
     * æ·»åŠ å–å•ä»·æ ¼å±‚çº§
     */
    public boolean addAsk(double price, long quantity) {
        return addPriceLevel(askHead, price, quantity, false);
    }
    
    /**
     * æ— é”æ·»åŠ ä»·æ ¼å±‚çº§
     */
    private boolean addPriceLevel(AtomicReference<PriceLevel> head, double price, long quantity, boolean isBid) {
        while (true) {
            PriceLevel currentHead = head.get();
            
            // æ£€æŸ¥æ˜¯å¦åº”è¯¥æ’å…¥åˆ°å¤´éƒ¨
            if (shouldInsertAtHead(currentHead, price, isBid)) {
                PriceLevel newLevel = new PriceLevel(price, quantity, currentHead);
                if (head.compareAndSet(currentHead, newLevel)) {
                    version.incrementAndGet();
                    return true;
                }
                // CASå¤±è´¥ï¼Œé‡è¯•
                continue;
            }
            
            // éœ€è¦æ’å…¥åˆ°ä¸­é—´æˆ–æœ«å°¾
            return insertInOrder(currentHead, price, quantity, isBid);
        }
    }
    
    /**
     * åˆ¤æ–­æ˜¯å¦åº”è¯¥æ’å…¥åˆ°å¤´éƒ¨
     */
    private boolean shouldInsertAtHead(PriceLevel head, double price, boolean isBid) {
        if (head == null) {
            return true;
        }
        
        if (isBid) {
            // ä¹°å•ï¼šä»·æ ¼é«˜çš„åœ¨å‰
            return price > head.price;
        } else {
            // å–å•ï¼šä»·æ ¼ä½çš„åœ¨å‰
            return price < head.price;
        }
    }
    
    /**
     * æŒ‰é¡ºåºæ’å…¥ä»·æ ¼å±‚çº§
     */
    private boolean insertInOrder(PriceLevel head, double price, long quantity, boolean isBid) {
        PriceLevel current = head;
        
        while (current != null) {
            PriceLevel next = current.next;
            
            // æ£€æŸ¥æ˜¯å¦æ‰¾åˆ°æ’å…¥ä½ç½®
            if (shouldInsertBetween(current, next, price, isBid)) {
                PriceLevel newLevel = new PriceLevel(price, quantity, next);
                
                // ä½¿ç”¨CASæ›´æ–°nextæŒ‡é’ˆ
                if (compareAndSetNext(current, next, newLevel)) {
                    version.incrementAndGet();
                    return true;
                }
                // CASå¤±è´¥ï¼Œé‡æ–°å¼€å§‹
                return false;
            }
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯ç›¸åŒä»·æ ¼ï¼ˆæ›´æ–°æ•°é‡ï¼‰
            if (current.price == price) {
                return updateQuantity(current, quantity);
            }
            
            current = next;
        }
        
        return false;
    }
    
    /**
     * åˆ¤æ–­æ˜¯å¦åº”è¯¥åœ¨ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´æ’å…¥
     */
    private boolean shouldInsertBetween(PriceLevel current, PriceLevel next, double price, boolean isBid) {
        if (next == null) {
            return true; // æ’å…¥åˆ°æœ«å°¾
        }
        
        if (isBid) {
            return current.price > price && price > next.price;
        } else {
            return current.price < price && price < next.price;
        }
    }
    
    /**
     * åŸå­æ€§æ›´æ–°nextæŒ‡é’ˆ
     */
    private boolean compareAndSetNext(PriceLevel node, PriceLevel expected, PriceLevel update) {
        // ä½¿ç”¨Unsafeè¿›è¡ŒCASæ“ä½œ
        return UNSAFE.compareAndSwapObject(node, NEXT_OFFSET, expected, update);
    }
    
    /**
     * åŸå­æ€§æ›´æ–°æ•°é‡
     */
    private boolean updateQuantity(PriceLevel level, long newQuantity) {
        // ä½¿ç”¨CASæ›´æ–°æ•°é‡
        long currentQuantity = level.quantity;
        if (UNSAFE.compareAndSwapLong(level, QUANTITY_OFFSET, currentQuantity, newQuantity)) {
            level.timestamp = System.nanoTime();
            version.incrementAndGet();
            return true;
        }
        return false;
    }
    
    /**
     * è·å–æœ€ä¼˜ä¹°ä»·
     */
    public double getBestBid() {
        PriceLevel head = bidHead.get();
        return head != null ? head.price : 0.0;
    }
    
    /**
     * è·å–æœ€ä¼˜å–ä»·
     */
    public double getBestAsk() {
        PriceLevel head = askHead.get();
        return head != null ? head.price : 0.0;
    }
    
    /**
     * è·å–ä»·å·®
     */
    public double getSpread() {
        return getBestAsk() - getBestBid();
    }
    
    /**
     * è·å–ç‰ˆæœ¬å·ï¼ˆç”¨äºæ£€æµ‹å˜åŒ–ï¼‰
     */
    public long getVersion() {
        return version.get();
    }
    
    /**
     * è·å–ä»·æ ¼ç°¿å¿«ç…§
     */
    public PriceBookSnapshot getSnapshot() {
        long snapshotVersion = version.get();
        PriceLevel bidSnapshot = copyPriceLevels(bidHead.get());
        PriceLevel askSnapshot = copyPriceLevels(askHead.get());
        
        return new PriceBookSnapshot(snapshotVersion, bidSnapshot, askSnapshot);
    }
    
    /**
     * å¤åˆ¶ä»·æ ¼å±‚çº§é“¾è¡¨
     */
    private PriceLevel copyPriceLevels(PriceLevel head) {
        if (head == null) {
            return null;
        }
        
        PriceLevel copy = new PriceLevel(head.price, head.quantity);
        copy.timestamp = head.timestamp;
        copy.next = copyPriceLevels(head.next);
        
        return copy;
    }
    
    // Unsafeç›¸å…³çš„é™æ€å­—æ®µå’Œåˆå§‹åŒ–
    private static final sun.misc.Unsafe UNSAFE;
    private static final long NEXT_OFFSET;
    private static final long QUANTITY_OFFSET;
    
    static {
        try {
            java.lang.reflect.Field field = sun.misc.Unsafe.class.getDeclaredField("theUnsafe");
            field.setAccessible(true);
            UNSAFE = (sun.misc.Unsafe) field.get(null);
            
            NEXT_OFFSET = UNSAFE.objectFieldOffset(PriceLevel.class.getDeclaredField("next"));
            QUANTITY_OFFSET = UNSAFE.objectFieldOffset(PriceLevel.class.getDeclaredField("quantity"));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
    
    /**
     * ä»·æ ¼ç°¿å¿«ç…§
     */
    public static class PriceBookSnapshot {
        private final long version;
        private final PriceLevel bidLevels;
        private final PriceLevel askLevels;
        
        public PriceBookSnapshot(long version, PriceLevel bidLevels, PriceLevel askLevels) {
            this.version = version;
            this.bidLevels = bidLevels;
            this.askLevels = askLevels;
        }
        
        public long getVersion() { return version; }
        public PriceLevel getBidLevels() { return bidLevels; }
        public PriceLevel getAskLevels() { return askLevels; }
    }
}
```

## ğŸ¯ æ€§èƒ½ä¼˜åŒ–æ£€æŸ¥æ¸…å•

### CPUçº§ä¼˜åŒ–

- [ ] **çº¿ç¨‹äº²å’Œæ€§**: ç»‘å®šå…³é”®çº¿ç¨‹åˆ°ç‰¹å®šCPUæ ¸å¿ƒ
- [ ] **NUMAæ„ŸçŸ¥**: å†…å­˜åˆ†é…åœ¨æ­£ç¡®çš„NUMAèŠ‚ç‚¹
- [ ] **è¶…çº¿ç¨‹ä¼˜åŒ–**: é¿å…å…³é”®çº¿ç¨‹å…±äº«ç‰©ç†æ ¸å¿ƒ
- [ ] **ä¸­æ–­äº²å’Œæ€§**: ç½‘ç»œä¸­æ–­ç»‘å®šåˆ°éå…³é”®CPU

### å†…å­˜çº§ä¼˜åŒ–

- [ ] **ç¼“å­˜è¡Œå¯¹é½**: é¿å…false sharing
- [ ] **å†…å­˜é¢„å–**: æå‰åŠ è½½å¯èƒ½è®¿é—®çš„æ•°æ®
- [ ] **å†…å­˜å±éšœ**: ç¡®ä¿å†…å­˜æ“ä½œçš„æ­£ç¡®é¡ºåº
- [ ] **å †å¤–å†…å­˜**: å‡å°‘GCå‹åŠ›

### å¹¶å‘çº§ä¼˜åŒ–

- [ ] **æ— é”æ•°æ®ç»“æ„**: æ¶ˆé™¤é”ç«äº‰
- [ ] **ç­‰å¾…ç­–ç•¥ä¼˜åŒ–**: é€‰æ‹©åˆé€‚çš„ç­‰å¾…ç­–ç•¥
- [ ] **æ‰¹å¤„ç†**: å‡å°‘ç³»ç»Ÿè°ƒç”¨å¼€é”€
- [ ] **äº‹ä»¶é©±åŠ¨**: é¿å…è½®è¯¢å¼€é”€

## ğŸ“š å­¦ä¹ è¦ç‚¹æ€»ç»“

### å…³é”®æ€§èƒ½æ¦‚å¿µ

1. **CPUäº²å’Œæ€§**: å‡å°‘çº¿ç¨‹è¿ç§»å’Œç¼“å­˜å¤±æ•ˆ
2. **å†…å­˜å±éšœ**: ç¡®ä¿å¤šçº¿ç¨‹ç¯å¢ƒä¸‹çš„å†…å­˜ä¸€è‡´æ€§
3. **æ— é”ç¼–ç¨‹**: ä½¿ç”¨CASæ“ä½œé¿å…é”ç«äº‰
4. **ç¼“å­˜ä¼˜åŒ–**: æå‡å†…å­˜è®¿é—®æ•ˆç‡

### ä¸‹ä¸€æ­¥å­¦ä¹ 

- [é¡¹ç›®2-æµ‹è¯•éªŒè¯.md](./é¡¹ç›®2-æµ‹è¯•éªŒè¯.md) - æ€§èƒ½æµ‹è¯•å’ŒéªŒè¯
- [é¡¹ç›®2-é¢è¯•å‡†å¤‡.md](./é¡¹ç›®2-é¢è¯•å‡†å¤‡.md) - é¢è¯•è¦ç‚¹æ€»ç»“

### é¢è¯•è¦ç‚¹

- èƒ½å¤Ÿè§£é‡Šæ— é”ç¼–ç¨‹çš„åŸç†å’Œåº”ç”¨åœºæ™¯
- ç†è§£CPUç¼“å­˜å’Œå†…å­˜å±‚æ¬¡ç»“æ„
- æŒæ¡Javaå¹¶å‘ç¼–ç¨‹çš„é«˜çº§æŠ€æœ¯